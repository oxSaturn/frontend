{
  "address": "0x3a9238141a4655d0dC907e18BBf9c21b843F09c7",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "existing_bribe",
          "type": "address"
        }
      ],
      "name": "createBribe",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "last_bribe",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "oldBribeToNew",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_voter",
          "type": "address"
        }
      ],
      "name": "setVoter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "voter",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xcfca807be156baa05697cfc25850242fcb593e2fcfdc895f810143f8d13872d0",
  "receipt": {
    "to": null,
    "from": "0x53f3B51FD7F327E1Ec4E6eAa3A049149cB2acaD2",
    "contractAddress": "0x3a9238141a4655d0dC907e18BBf9c21b843F09c7",
    "transactionIndex": 0,
    "gasUsed": "1939128",
    "logsBloom": "0x00000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000020000000000000000000000000000000008000000000000000000100000000000000000000000000000020000000100000000000800000000000000000000000050000000000000000000000000000000000000000000000000000000000000000000000000000000000004800000000000000000000000800000000000000000000000000000000002000000000000000000000000000000000010000000000000000020000000000000000000000000000000000000000010000000000000000000000002",
    "blockHash": "0xc33916edd3e021330e1bab47c6b580607574d8ca92ce372a59a09e65b4ac5687",
    "transactionHash": "0xcfca807be156baa05697cfc25850242fcb593e2fcfdc895f810143f8d13872d0",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 2975088,
        "transactionHash": "0xcfca807be156baa05697cfc25850242fcb593e2fcfdc895f810143f8d13872d0",
        "address": "0xEcf044C5B4b867CFda001101c617eCd347095B44",
        "topics": [
          "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x0000000000000000000000000a178469e3d08beaa0a289e416ab924f10807989",
          "0x00000000000000000000000000000000000000000000000000000000000000cf"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0xc33916edd3e021330e1bab47c6b580607574d8ca92ce372a59a09e65b4ac5687"
      },
      {
        "transactionIndex": 0,
        "blockNumber": 2975088,
        "transactionHash": "0xcfca807be156baa05697cfc25850242fcb593e2fcfdc895f810143f8d13872d0",
        "address": "0xEcf044C5B4b867CFda001101c617eCd347095B44",
        "topics": [
          "0xcc0bec1447060c88cdc5a739cf29cfa26c453574dd3f5b9e4dcc317d6401cb1c"
        ],
        "data": "0x0000000000000000000000003a9238141a4655d0dc907e18bbf9c21b843f09c70000000000000000000000000a178469e3d08beaa0a289e416ab924f1080798900000000000000000000000000000000000000000000000000000000000000cf",
        "logIndex": 1,
        "blockHash": "0xc33916edd3e021330e1bab47c6b580607574d8ca92ce372a59a09e65b4ac5687"
      }
    ],
    "blockNumber": 2975088,
    "cumulativeGasUsed": "1939128",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "35e0ac8ae47caef0caca6801c152e6fb",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"existing_bribe\",\"type\":\"address\"}],\"name\":\"createBribe\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"last_bribe\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"oldBribeToNew\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"}],\"name\":\"setVoter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/factories/WrappedExternalBribeFactory.sol\":\"WrappedExternalBribeFactory\"},\"evmVersion\":\"london\",\"libraries\":{\":__CACHE_BREAKER__\":\"0x0000000000000031363736353439383830373835\"},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/ExternalBribe.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\\\";\\n\\nimport \\\"contracts/interfaces/IBribe.sol\\\";\\nimport \\\"contracts/interfaces/IERC20.sol\\\";\\nimport \\\"contracts/interfaces/IGauge.sol\\\";\\nimport \\\"contracts/interfaces/IVoter.sol\\\";\\nimport \\\"contracts/interfaces/IVotingEscrow.sol\\\";\\nimport \\\"contracts/interfaces/ITurnstile.sol\\\";\\n\\n// Bribes pay out rewards for a given pool based on the votes that were received from the user (goes hand in hand with Voter.vote())\\ncontract ExternalBribe is IBribe {\\n    address internal multisig = 0x0a178469E3d08BEAA0a289E416Ab924F10807989;\\n    address internal turnstile = 0xEcf044C5B4b867CFda001101c617eCd347095B44;\\n    address public immutable voter; // only voter can modify balances (since it only happens on vote())\\n    address public immutable _ve; // \\u5929\\u4f7f\\u306e\\u305f\\u307e\\u3054\\n\\n    uint256 internal constant DURATION = 7 days; // rewards are released over the voting period\\n    uint256 internal constant MAX_REWARD_TOKENS = 16;\\n\\n    uint256 internal constant PRECISION = 10**18;\\n\\n    uint256 public totalSupply;\\n    mapping(uint256 => uint256) public balanceOf;\\n    mapping(address => mapping(uint256 => uint256)) public tokenRewardsPerEpoch;\\n    mapping(address => uint256) public periodFinish;\\n    mapping(address => mapping(uint256 => uint256)) public lastEarn;\\n\\n    address[] public rewards;\\n    mapping(address => bool) public isReward;\\n\\n    /// @notice A checkpoint for marking balance\\n    struct Checkpoint {\\n        uint256 timestamp;\\n        uint256 balanceOf;\\n    }\\n\\n    /// @notice A checkpoint for marking supply\\n    struct SupplyCheckpoint {\\n        uint256 timestamp;\\n        uint256 supply;\\n    }\\n\\n    /// @notice A record of balance checkpoints for each account, by index\\n    mapping(uint256 => mapping(uint256 => Checkpoint)) public checkpoints;\\n    /// @notice The number of checkpoints for each account\\n    mapping(uint256 => uint256) public numCheckpoints;\\n    /// @notice A record of balance checkpoints for each token, by index\\n    mapping(uint256 => SupplyCheckpoint) public supplyCheckpoints;\\n    /// @notice The number of checkpoints\\n    uint256 public supplyNumCheckpoints;\\n\\n    event Deposit(address indexed from, uint256 tokenId, uint256 amount);\\n    event Withdraw(address indexed from, uint256 tokenId, uint256 amount);\\n    event NotifyReward(\\n        address indexed from,\\n        address indexed reward,\\n        uint256 epoch,\\n        uint256 amount\\n    );\\n    event ClaimRewards(\\n        address indexed from,\\n        address indexed reward,\\n        uint256 amount\\n    );\\n\\n    constructor(address _voter, address[] memory _allowedRewardTokens) {\\n        voter = _voter;\\n        _ve = IVoter(_voter)._ve();\\n\\n        for (uint256 i; i < _allowedRewardTokens.length; i++) {\\n            if (_allowedRewardTokens[i] != address(0)) {\\n                isReward[_allowedRewardTokens[i]] = true;\\n                rewards.push(_allowedRewardTokens[i]);\\n            }\\n        }\\n\\n        ITurnstile(turnstile).register(multisig);\\n    }\\n\\n    // simple re-entrancy check\\n    uint256 internal _unlocked = 1;\\n    modifier lock() {\\n        require(_unlocked == 1);\\n        _unlocked = 2;\\n        _;\\n        _unlocked = 1;\\n    }\\n\\n    function _bribeStart(uint256 timestamp) internal pure returns (uint256) {\\n        return timestamp - (timestamp % (7 days));\\n    }\\n\\n    function getEpochStart(uint256 timestamp) public pure returns (uint256) {\\n        uint256 bribeStart = _bribeStart(timestamp);\\n        uint256 bribeEnd = bribeStart + DURATION;\\n        return timestamp < bribeEnd ? bribeStart : bribeStart + 7 days;\\n    }\\n\\n    /**\\n     * @notice Determine the prior balance for an account as of a block number\\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\\n     * @param tokenId The token of the NFT to check\\n     * @param timestamp The timestamp to get the balance at\\n     * @return The balance the account had as of the given block\\n     */\\n    function getPriorBalanceIndex(uint256 tokenId, uint256 timestamp)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 nCheckpoints = numCheckpoints[tokenId];\\n        if (nCheckpoints == 0) {\\n            return 0;\\n        }\\n        // First check most recent balance\\n        if (checkpoints[tokenId][nCheckpoints - 1].timestamp <= timestamp) {\\n            return (nCheckpoints - 1);\\n        }\\n        // Next check implicit zero balance\\n        if (checkpoints[tokenId][0].timestamp > timestamp) {\\n            return 0;\\n        }\\n\\n        uint256 lower = 0;\\n        uint256 upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            Checkpoint memory cp = checkpoints[tokenId][center];\\n            if (cp.timestamp == timestamp) {\\n                return center;\\n            } else if (cp.timestamp < timestamp) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return lower;\\n    }\\n\\n    function getPriorSupplyIndex(uint256 timestamp)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 nCheckpoints = supplyNumCheckpoints;\\n        if (nCheckpoints == 0) {\\n            return 0;\\n        }\\n\\n        // First check most recent balance\\n        if (supplyCheckpoints[nCheckpoints - 1].timestamp <= timestamp) {\\n            return (nCheckpoints - 1);\\n        }\\n\\n        // Next check implicit zero balance\\n        if (supplyCheckpoints[0].timestamp > timestamp) {\\n            return 0;\\n        }\\n\\n        uint256 lower = 0;\\n        uint256 upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            SupplyCheckpoint memory cp = supplyCheckpoints[center];\\n            if (cp.timestamp == timestamp) {\\n                return center;\\n            } else if (cp.timestamp < timestamp) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return lower;\\n    }\\n\\n    function _writeCheckpoint(uint256 tokenId, uint256 balance) internal {\\n        uint256 _timestamp = block.timestamp;\\n        uint256 _nCheckPoints = numCheckpoints[tokenId];\\n        if (\\n            _nCheckPoints > 0 &&\\n            checkpoints[tokenId][_nCheckPoints - 1].timestamp == _timestamp\\n        ) {\\n            checkpoints[tokenId][_nCheckPoints - 1].balanceOf = balance;\\n        } else {\\n            checkpoints[tokenId][_nCheckPoints] = Checkpoint(\\n                _timestamp,\\n                balance\\n            );\\n            numCheckpoints[tokenId] = _nCheckPoints + 1;\\n        }\\n    }\\n\\n    function _writeSupplyCheckpoint() internal {\\n        uint256 _nCheckPoints = supplyNumCheckpoints;\\n        uint256 _timestamp = block.timestamp;\\n\\n        if (\\n            _nCheckPoints > 0 &&\\n            supplyCheckpoints[_nCheckPoints - 1].timestamp == _timestamp\\n        ) {\\n            supplyCheckpoints[_nCheckPoints - 1].supply = totalSupply;\\n        } else {\\n            supplyCheckpoints[_nCheckPoints] = SupplyCheckpoint(\\n                _timestamp,\\n                totalSupply\\n            );\\n            supplyNumCheckpoints = _nCheckPoints + 1;\\n        }\\n    }\\n\\n    function rewardsListLength() external view returns (uint256) {\\n        return rewards.length;\\n    }\\n\\n    // returns the last time the reward was modified or periodFinish if the reward has ended\\n    function lastTimeRewardApplicable(address token)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return Math.min(block.timestamp, periodFinish[token]);\\n    }\\n\\n    // allows a user to claim rewards for a given token\\n    function getReward(uint256 tokenId, address[] memory tokens) external lock {\\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, tokenId));\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            uint256 _reward = earned(tokens[i], tokenId);\\n            lastEarn[tokens[i]][tokenId] = block.timestamp;\\n            if (_reward > 0) _safeTransfer(tokens[i], msg.sender, _reward);\\n\\n            emit ClaimRewards(msg.sender, tokens[i], _reward);\\n        }\\n    }\\n\\n    // used by Voter to allow batched reward claims\\n    function getRewardForOwner(uint256 tokenId, address[] memory tokens)\\n        external\\n        lock\\n    {\\n        require(msg.sender == voter);\\n        address _owner = IVotingEscrow(_ve).ownerOf(tokenId);\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            uint256 _reward = earned(tokens[i], tokenId);\\n            lastEarn[tokens[i]][tokenId] = block.timestamp;\\n            if (_reward > 0) _safeTransfer(tokens[i], _owner, _reward);\\n\\n            emit ClaimRewards(_owner, tokens[i], _reward);\\n        }\\n    }\\n\\n    function earned(address token, uint256 tokenId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 _startTimestamp = lastEarn[token][tokenId];\\n        if (numCheckpoints[tokenId] == 0) {\\n            return 0;\\n        }\\n\\n        uint256 _startIndex = getPriorBalanceIndex(tokenId, _startTimestamp);\\n        uint256 _endIndex = numCheckpoints[tokenId] - 1;\\n\\n        uint256 reward = 0;\\n        // you only earn once per epoch (after it's over)\\n        Checkpoint memory prevRewards; // reuse struct to avoid stack too deep\\n        prevRewards.timestamp = _bribeStart(_startTimestamp);\\n        uint256 _prevSupply = 1;\\n\\n        if (_endIndex > 0) {\\n            for (uint256 i = _startIndex; i <= _endIndex - 1; i++) {\\n                Checkpoint memory cp0 = checkpoints[tokenId][i];\\n                uint256 _nextEpochStart = _bribeStart(cp0.timestamp);\\n                // check that you've earned it\\n                // this won't happen until a week has passed\\n                if (_nextEpochStart > prevRewards.timestamp) {\\n                    reward += prevRewards.balanceOf;\\n                }\\n\\n                prevRewards.timestamp = _nextEpochStart;\\n                _prevSupply = supplyCheckpoints[\\n                    getPriorSupplyIndex(_nextEpochStart + DURATION)\\n                ].supply;\\n                prevRewards.balanceOf =\\n                    (cp0.balanceOf *\\n                        tokenRewardsPerEpoch[token][_nextEpochStart]) /\\n                    _prevSupply;\\n            }\\n        }\\n\\n        Checkpoint memory cp = checkpoints[tokenId][_endIndex];\\n        uint256 _lastEpochStart = _bribeStart(cp.timestamp);\\n        uint256 _lastEpochEnd = _lastEpochStart + DURATION;\\n\\n        if (block.timestamp > _lastEpochEnd) {\\n            reward +=\\n                (cp.balanceOf * tokenRewardsPerEpoch[token][_lastEpochStart]) /\\n                supplyCheckpoints[getPriorSupplyIndex(_lastEpochEnd)].supply;\\n        }\\n\\n        return reward;\\n    }\\n\\n    // This is an external function, but internal notation is used since it can only be called \\\"internally\\\" from Gauges\\n    function _deposit(uint256 amount, uint256 tokenId) external {\\n        require(msg.sender == voter);\\n\\n        totalSupply += amount;\\n        balanceOf[tokenId] += amount;\\n\\n        _writeCheckpoint(tokenId, balanceOf[tokenId]);\\n        _writeSupplyCheckpoint();\\n\\n        emit Deposit(msg.sender, tokenId, amount);\\n    }\\n\\n    function _withdraw(uint256 amount, uint256 tokenId) external {\\n        require(msg.sender == voter);\\n\\n        totalSupply -= amount;\\n        balanceOf[tokenId] -= amount;\\n\\n        _writeCheckpoint(tokenId, balanceOf[tokenId]);\\n        _writeSupplyCheckpoint();\\n\\n        emit Withdraw(msg.sender, tokenId, amount);\\n    }\\n\\n    function left(address token) external view returns (uint256) {\\n        uint256 adjustedTstamp = getEpochStart(block.timestamp);\\n        return tokenRewardsPerEpoch[token][adjustedTstamp];\\n    }\\n\\n    function notifyRewardAmount(address token, uint256 amount) external lock {\\n        require(amount > 0);\\n        if (!isReward[token]) {\\n            require(\\n                IVoter(voter).isWhitelisted(token),\\n                \\\"bribe tokens must be whitelisted\\\"\\n            );\\n            require(\\n                rewards.length < MAX_REWARD_TOKENS,\\n                \\\"too many rewards tokens\\\"\\n            );\\n        }\\n        // bribes kick in at the start of next bribe period\\n        uint256 adjustedTstamp = getEpochStart(block.timestamp);\\n        uint256 epochRewards = tokenRewardsPerEpoch[token][adjustedTstamp];\\n\\n        _safeTransferFrom(token, msg.sender, address(this), amount);\\n        tokenRewardsPerEpoch[token][adjustedTstamp] = epochRewards + amount;\\n\\n        periodFinish[token] = adjustedTstamp + DURATION;\\n\\n        if (!isReward[token]) {\\n            isReward[token] = true;\\n            rewards.push(token);\\n        }\\n\\n        emit NotifyReward(msg.sender, token, adjustedTstamp, amount);\\n    }\\n\\n    function swapOutRewardToken(\\n        uint256 i,\\n        address oldToken,\\n        address newToken\\n    ) external {\\n        require(msg.sender == IVotingEscrow(_ve).team(), \\\"only team\\\");\\n        require(rewards[i] == oldToken);\\n        isReward[oldToken] = false;\\n        isReward[newToken] = true;\\n        rewards[i] = newToken;\\n    }\\n\\n    function _safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        require(token.code.length > 0);\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(IERC20.transfer.selector, to, value)\\n        );\\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\\n    }\\n\\n    function _safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        require(token.code.length > 0);\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(\\n                IERC20.transferFrom.selector,\\n                from,\\n                to,\\n                value\\n            )\\n        );\\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\\n    }\\n}\\n\",\"keccak256\":\"0xca2f77876c2b9b0745bd54ac91716a02640bbafa181b2a9811aab3d5c2893503\",\"license\":\"MIT\"},\"contracts/WrappedExternalBribe.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\\\";\\nimport \\\"contracts/ExternalBribe.sol\\\";\\nimport \\\"contracts/interfaces/IERC20.sol\\\";\\nimport \\\"contracts/interfaces/IGauge.sol\\\";\\nimport \\\"contracts/interfaces/IVoter.sol\\\";\\nimport \\\"contracts/interfaces/IVotingEscrow.sol\\\";\\nimport \\\"contracts/interfaces/ITurnstile.sol\\\";\\n\\n// Bribes pay out rewards for a given pool based on the votes that were received from the user (goes hand in hand with Voter.vote())\\ncontract WrappedExternalBribe {\\n    address internal multisig = 0x0a178469E3d08BEAA0a289E416Ab924F10807989;\\n    address internal turnstile = 0xEcf044C5B4b867CFda001101c617eCd347095B44;\\n    address public immutable voter;\\n    address public immutable _ve;\\n    ExternalBribe public underlying_bribe;\\n\\n    uint256 internal constant DURATION = 7 days; // rewards are released over the voting period\\n    uint256 internal constant MAX_REWARD_TOKENS = 16;\\n\\n    uint256 internal constant PRECISION = 10**18;\\n\\n    mapping(address => mapping(uint256 => uint256)) public tokenRewardsPerEpoch;\\n    mapping(address => uint256) public periodFinish;\\n    mapping(address => mapping(uint256 => uint256)) public lastEarn;\\n\\n    address[] public rewards;\\n    mapping(address => bool) public isReward;\\n\\n    /// @notice A checkpoint for marking balance\\n    struct RewardCheckpoint {\\n        uint256 timestamp;\\n        uint256 balance;\\n    }\\n\\n    event NotifyReward(\\n        address indexed from,\\n        address indexed reward,\\n        uint256 epoch,\\n        uint256 amount\\n    );\\n    event ClaimRewards(\\n        address indexed from,\\n        address indexed reward,\\n        uint256 amount\\n    );\\n\\n    constructor(address _voter, address _old_bribe) {\\n        voter = _voter;\\n        _ve = IVoter(_voter)._ve();\\n        underlying_bribe = ExternalBribe(_old_bribe);\\n\\n        for (uint256 i; i < underlying_bribe.rewardsListLength(); i++) {\\n            address underlying_reward = underlying_bribe.rewards(i);\\n            if (underlying_reward != address(0)) {\\n                isReward[underlying_reward] = true;\\n                rewards.push(underlying_reward);\\n            }\\n        }\\n\\n        ITurnstile(turnstile).register(multisig);\\n    }\\n\\n    // simple re-entrancy check\\n    uint256 internal _unlocked = 1;\\n    modifier lock() {\\n        require(_unlocked == 1);\\n        _unlocked = 2;\\n        _;\\n        _unlocked = 1;\\n    }\\n\\n    function _bribeStart(uint256 timestamp) internal pure returns (uint256) {\\n        return timestamp - (timestamp % (7 days));\\n    }\\n\\n    function getEpochStart(uint256 timestamp) public pure returns (uint256) {\\n        uint256 bribeStart = _bribeStart(timestamp);\\n        uint256 bribeEnd = bribeStart + DURATION;\\n        return timestamp < bribeEnd ? bribeStart : bribeStart + 7 days;\\n    }\\n\\n    function rewardsListLength() external view returns (uint256) {\\n        return rewards.length;\\n    }\\n\\n    // returns the last time the reward was modified or periodFinish if the reward has ended\\n    function lastTimeRewardApplicable(address token)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return Math.min(block.timestamp, periodFinish[token]);\\n    }\\n\\n    // allows a user to claim rewards for a given token\\n    function getReward(uint256 tokenId, address[] memory tokens) external lock {\\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, tokenId));\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            uint256 _reward = earned(tokens[i], tokenId);\\n            lastEarn[tokens[i]][tokenId] = block.timestamp;\\n            if (_reward > 0) _safeTransfer(tokens[i], msg.sender, _reward);\\n\\n            emit ClaimRewards(msg.sender, tokens[i], _reward);\\n        }\\n    }\\n\\n    // used by Voter to allow batched reward claims\\n    function getRewardForOwner(uint256 tokenId, address[] memory tokens)\\n        external\\n        lock\\n    {\\n        require(msg.sender == voter);\\n        address _owner = IVotingEscrow(_ve).ownerOf(tokenId);\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            uint256 _reward = earned(tokens[i], tokenId);\\n            lastEarn[tokens[i]][tokenId] = block.timestamp;\\n            if (_reward > 0) _safeTransfer(tokens[i], _owner, _reward);\\n\\n            emit ClaimRewards(_owner, tokens[i], _reward);\\n        }\\n    }\\n\\n    function earned(address token, uint256 tokenId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 _startTimestamp = lastEarn[token][tokenId];\\n        if (underlying_bribe.numCheckpoints(tokenId) == 0) {\\n            return 0;\\n        }\\n\\n        uint256 _startIndex = underlying_bribe.getPriorBalanceIndex(\\n            tokenId,\\n            _startTimestamp\\n        );\\n        uint256 _endIndex = underlying_bribe.numCheckpoints(tokenId) - 1;\\n\\n        uint256 reward = 0;\\n        // you only earn once per epoch (after it's over)\\n        RewardCheckpoint memory prevRewards;\\n        prevRewards.timestamp = _bribeStart(_startTimestamp);\\n        uint256 _prevTs = 0;\\n        uint256 _prevBal = 0;\\n        uint256 _prevSupply = 1;\\n\\n        if (_endIndex > 0) {\\n            for (uint256 i = _startIndex; i <= _endIndex - 1; i++) {\\n                (_prevTs, _prevBal) = underlying_bribe.checkpoints(tokenId, i);\\n                uint256 _nextEpochStart = _bribeStart(_prevTs);\\n                // check that you've earned it\\n                // this won't happen until a week has passed\\n                if (_nextEpochStart > prevRewards.timestamp) {\\n                    reward += prevRewards.balance;\\n                }\\n\\n                prevRewards.timestamp = _nextEpochStart;\\n                (, _prevSupply) = underlying_bribe.supplyCheckpoints(\\n                    underlying_bribe.getPriorSupplyIndex(\\n                        _nextEpochStart + DURATION\\n                    )\\n                );\\n                prevRewards.balance =\\n                    (_prevBal * tokenRewardsPerEpoch[token][_nextEpochStart]) /\\n                    _prevSupply;\\n            }\\n        }\\n\\n        (_prevTs, _prevBal) = underlying_bribe.checkpoints(tokenId, _endIndex);\\n        uint256 _lastEpochStart = _bribeStart(_prevTs);\\n        uint256 _lastEpochEnd = _lastEpochStart + DURATION;\\n\\n        if (\\n            block.timestamp > _lastEpochEnd && _startTimestamp < _lastEpochEnd\\n        ) {\\n            (, _prevSupply) = underlying_bribe.supplyCheckpoints(\\n                underlying_bribe.getPriorSupplyIndex(_lastEpochEnd)\\n            );\\n            reward +=\\n                (_prevBal * tokenRewardsPerEpoch[token][_lastEpochStart]) /\\n                _prevSupply;\\n        }\\n\\n        return reward;\\n    }\\n\\n    function left(address token) external view returns (uint256) {\\n        uint256 adjustedTstamp = getEpochStart(block.timestamp);\\n        return tokenRewardsPerEpoch[token][adjustedTstamp];\\n    }\\n\\n    function notifyRewardAmount(address token, uint256 amount) external lock {\\n        require(amount > 0);\\n        if (!isReward[token]) {\\n            require(\\n                IVoter(voter).isWhitelisted(token),\\n                \\\"bribe tokens must be whitelisted\\\"\\n            );\\n            require(\\n                rewards.length < MAX_REWARD_TOKENS,\\n                \\\"too many rewards tokens\\\"\\n            );\\n        }\\n        // bribes kick in at the start of next bribe period\\n        uint256 adjustedTstamp = getEpochStart(block.timestamp);\\n        uint256 epochRewards = tokenRewardsPerEpoch[token][adjustedTstamp];\\n\\n        _safeTransferFrom(token, msg.sender, address(this), amount);\\n        tokenRewardsPerEpoch[token][adjustedTstamp] = epochRewards + amount;\\n\\n        periodFinish[token] = adjustedTstamp + DURATION;\\n\\n        if (!isReward[token]) {\\n            isReward[token] = true;\\n            rewards.push(token);\\n        }\\n\\n        emit NotifyReward(msg.sender, token, adjustedTstamp, amount);\\n    }\\n\\n    function swapOutRewardToken(\\n        uint256 i,\\n        address oldToken,\\n        address newToken\\n    ) external {\\n        require(msg.sender == IVotingEscrow(_ve).team(), \\\"only team\\\");\\n        require(rewards[i] == oldToken);\\n        isReward[oldToken] = false;\\n        isReward[newToken] = true;\\n        rewards[i] = newToken;\\n    }\\n\\n    function _safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        require(token.code.length > 0);\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(IERC20.transfer.selector, to, value)\\n        );\\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\\n    }\\n\\n    function _safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        require(token.code.length > 0);\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(\\n                IERC20.transferFrom.selector,\\n                from,\\n                to,\\n                value\\n            )\\n        );\\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\\n    }\\n}\\n\",\"keccak256\":\"0xe430a146a11efa36e88e11519209b173e5b538581aab16b9640653f3266f7f1c\",\"license\":\"MIT\"},\"contracts/factories/WrappedExternalBribeFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport {WrappedExternalBribe} from 'contracts/WrappedExternalBribe.sol';\\nimport \\\"contracts/interfaces/ITurnstile.sol\\\";\\n\\ncontract WrappedExternalBribeFactory {\\n    address internal multisig = 0x0a178469E3d08BEAA0a289E416Ab924F10807989;\\n    address internal turnstile = 0xEcf044C5B4b867CFda001101c617eCd347095B44;\\n    bool internal _initialized;\\n    address public voter;\\n    mapping(address => address) public oldBribeToNew;\\n    address public last_bribe;\\n\\n    constructor() {\\n        ITurnstile(turnstile).register(multisig);\\n    }\\n\\n    function createBribe(address existing_bribe) external returns (address) {\\n        require(\\n            oldBribeToNew[existing_bribe] == address(0),\\n            \\\"Wrapped bribe already created\\\"\\n        );\\n        last_bribe = address(new WrappedExternalBribe(voter, existing_bribe));\\n        oldBribeToNew[existing_bribe] = last_bribe;\\n        return last_bribe;\\n    }\\n\\n    function setVoter(address _voter) external {\\n        require(!_initialized, \\\"Already initialized\\\");\\n        voter = _voter;\\n        _initialized = true;\\n    }\\n}\\n\",\"keccak256\":\"0x459f0d3ccbcc954c11a58c32cd0a099a5e4816767a51b2b024bcf91003b0c951\",\"license\":\"MIT\"},\"contracts/interfaces/IBribe.sol\":{\"content\":\"pragma solidity 0.8.13;\\n\\ninterface IBribe {\\n    function _deposit(uint256 amount, uint256 tokenId) external;\\n    function _withdraw(uint256 amount, uint256 tokenId) external;\\n    function getRewardForOwner(uint256 tokenId, address[] memory tokens) external;\\n    function notifyRewardAmount(address token, uint256 amount) external; //keep same as external bribe\\n    function left(address token) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x05d9a4d56b9e7ef3e876873b0ef701474a7b5cca9494d61f083bd3207d531f74\"},\"contracts/interfaces/IERC20.sol\":{\"content\":\"pragma solidity 0.8.13;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function transfer(address recipient, uint amount) external returns (bool);\\n    function decimals() external view returns (uint8);\\n    function symbol() external view returns (string memory);\\n    function balanceOf(address) external view returns (uint);\\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint);\\n    function approve(address spender, uint value) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint value);\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\",\"keccak256\":\"0x892b167ec5245b43ccdfc68d20e8ca12d05725fb6c11ec5ddf6bf77ed0c93c32\"},\"contracts/interfaces/IGauge.sol\":{\"content\":\"pragma solidity 0.8.13;\\n\\ninterface IGauge {\\n    function notifyRewardAmount(address token, uint amount) external;\\n    function getReward(address account, address[] memory tokens) external;\\n    function claimFees() external returns (uint claimed0, uint claimed1);\\n    function left(address token) external view returns (uint);\\n    function isForPair() external view returns (bool);\\n}\\n\",\"keccak256\":\"0xae388a0eeb0318da9a00bd65bcc80dcbf81cd24915959c7852f9fa21f8893865\"},\"contracts/interfaces/ITurnstile.sol\":{\"content\":\"interface ITurnstile {\\n    function register(address) external returns(uint256);\\n}\",\"keccak256\":\"0xf19540479e9afad63b889bd1aaf665c5f989635ffc3259b9cfb600c079cf25f2\"},\"contracts/interfaces/IVoter.sol\":{\"content\":\"pragma solidity 0.8.13;\\n\\ninterface IVoter {\\n    function _ve() external view returns (address);\\n    function governor() external view returns (address);\\n    function emergencyCouncil() external view returns (address);\\n    function attachTokenToGauge(uint _tokenId, address account) external;\\n    function detachTokenFromGauge(uint _tokenId, address account) external;\\n    function emitDeposit(uint _tokenId, address account, uint amount) external;\\n    function emitWithdraw(uint _tokenId, address account, uint amount) external;\\n    function isWhitelisted(address token) external view returns (bool);\\n    function notifyRewardAmount(uint amount) external;\\n    function distribute(address _gauge) external;\\n}\\n\",\"keccak256\":\"0x033115b88f156c6db67ca468fc9da8e4197bbd48bc8cf5a1652b9ebd307b2d31\"},\"contracts/interfaces/IVotingEscrow.sol\":{\"content\":\"pragma solidity 0.8.13;\\n\\ninterface IVotingEscrow {\\n\\n    struct Point {\\n        int128 bias;\\n        int128 slope; // # -dweight / dt\\n        uint256 ts;\\n        uint256 blk; // block\\n    }\\n\\n    function token() external view returns (address);\\n    function team() external returns (address);\\n    function epoch() external view returns (uint);\\n    function point_history(uint loc) external view returns (Point memory);\\n    function user_point_history(uint tokenId, uint loc) external view returns (Point memory);\\n    function user_point_epoch(uint tokenId) external view returns (uint);\\n\\n    function ownerOf(uint) external view returns (address);\\n    function isApprovedOrOwner(address, uint) external view returns (bool);\\n    function transferFrom(address, address, uint) external;\\n\\n    function voting(uint tokenId) external;\\n    function abstain(uint tokenId) external;\\n    function attach(uint tokenId) external;\\n    function detach(uint tokenId) external;\\n\\n    function checkpoint() external;\\n    function deposit_for(uint tokenId, uint value) external;\\n    function create_lock_for(uint, uint, address) external returns (uint);\\n\\n    function balanceOfNFT(uint) external view returns (uint);\\n    function totalSupply() external view returns (uint);\\n}\\n\",\"keccak256\":\"0x9c51afef11e82c70d08871264602e385a4f7caf36383e1bc5a6c214f93a4c0d1\"},\"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3546b156d97633f7f8cad536d5454c81d1d604687c02b2eb105fdc33cb962b41\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6080604052600080546001600160a01b0319908116730a178469e3d08beaa0a289e416ab924f10807989179091556001805490911673ecf044c5b4b867cfda001101c617ecd347095b4417905534801561005857600080fd5b50600154600054604051632210724360e11b81526001600160a01b039182166004820152911690634420e486906024016020604051808303816000875af11580156100a7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100cb91906100d1565b506100ea565b6000602082840312156100e357600080fd5b5051919050565b611e0f806100f96000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c80632fcd8f271461005c57806346c96aac146100a15780634bc2a657146100b45780636bd1a72c146100c9578063b1d0fc82146100dc575b600080fd5b61008561006a366004610287565b6003602052600090815260409020546001600160a01b031681565b6040516001600160a01b03909116815260200160405180910390f35b600254610085906001600160a01b031681565b6100c76100c2366004610287565b6100ef565b005b6100856100d7366004610287565b61017a565b600454610085906001600160a01b031681565b600154600160a01b900460ff16156101445760405162461bcd60e51b8152602060048201526013602482015272105b1c9958591e481a5b9a5d1a585b1a5e9959606a1b60448201526064015b60405180910390fd5b600280546001600160a01b039092166001600160a01b03199092169190911790556001805460ff60a01b1916600160a01b179055565b6001600160a01b03818116600090815260036020526040812054909116156101e45760405162461bcd60e51b815260206004820152601d60248201527f5772617070656420627269626520616c72656164792063726561746564000000604482015260640161013b565b6002546040516001600160a01b039091169083906102019061027a565b6001600160a01b03928316815291166020820152604001604051809103906000f080158015610234573d6000803e3d6000fd5b50600480546001600160a01b039283166001600160a01b031991821681178355948316600090815260036020526040902080549091169094179093559154909116919050565b611b22806102b883390190565b60006020828403121561029957600080fd5b81356001600160a01b03811681146102b057600080fd5b939250505056fe60c0604052600080546001600160a01b0319908116730a178469e3d08beaa0a289e416ab924f10807989179091556001805490911673ecf044c5b4b867cfda001101c617ecd347095b441781556008553480156200005c57600080fd5b5060405162001b2238038062001b228339810160408190526200007f9162000335565b6001600160a01b038216608081905260408051638dd598fb60e01b81529051638dd598fb916004808201926020929091908290030181865afa158015620000ca573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620000f091906200036d565b6001600160a01b0390811660a052600280546001600160a01b03191691831691909117905560005b600260009054906101000a90046001600160a01b03166001600160a01b031663e68863966040518163ffffffff1660e01b8152600401602060405180830381865afa1580156200016c573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062000192919062000392565b8110156200029957600254604051637980d7a160e11b8152600481018390526000916001600160a01b03169063f301af4290602401602060405180830381865afa158015620001e5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020b91906200036d565b90506001600160a01b0381161562000283576001600160a01b0381166000818152600760205260408120805460ff191660019081179091556006805491820181559091527ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f0180546001600160a01b03191690911790555b50806200029081620003ac565b91505062000118565b50600154600054604051632210724360e11b81526001600160a01b039182166004820152911690634420e486906024016020604051808303816000875af1158015620002e9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200030f919062000392565b505050620003d4565b80516001600160a01b03811681146200033057600080fd5b919050565b600080604083850312156200034957600080fd5b620003548362000318565b9150620003646020840162000318565b90509250929050565b6000602082840312156200038057600080fd5b6200038b8262000318565b9392505050565b600060208284031215620003a557600080fd5b5051919050565b600060018201620003cd57634e487b7160e01b600052601160045260246000fd5b5060010190565b60805160a0516117056200041d600039600081816101e6015281816108f401528181610b1e0152610fd801526000818161014e01528181610adb0152610d1901526117056000f3fe608060405234801561001057600080fd5b506004361061010b5760003560e01c80639418f939116100a2578063da09d19d11610071578063da09d19d14610281578063e6886396146102a1578063f25e55a5146102a9578063f301af42146102d4578063f5f8d365146102e757600080fd5b80639418f9391461023357806399bcc05214610248578063a7852afa1461025b578063b66503cf1461026e57600080fd5b8063638634ee116100de578063638634ee146101bb5780636c4f5398146101ce5780638dd598fb146101e157806392777b291461020857600080fd5b80630175e23b146101105780633e491d471461013657806346c96aac146101495780634d5ce03814610188575b600080fd5b61012361011e366004611394565b6102fa565b6040519081526020015b60405180910390f35b6101236101443660046113d5565b61033c565b6101707f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b03909116815260200161012d565b6101ab610196366004611401565b60076020526000908152604090205460ff1681565b604051901515815260200161012d565b6101236101c9366004611401565b6108ce565b600254610170906001600160a01b031681565b6101707f000000000000000000000000000000000000000000000000000000000000000081565b6101236102163660046113d5565b600360209081526000928352604080842090915290825290205481565b61024661024136600461141e565b6108f2565b005b610123610256366004611401565b610a83565b610246610269366004611476565b610abc565b61024661027c3660046113d5565b610cbc565b61012361028f366004611401565b60046020526000908152604090205481565b600654610123565b6101236102b73660046113d5565b600560209081526000928352604080842090915290825290205481565b6101706102e2366004611394565b610f7e565b6102466102f5366004611476565b610fa8565b6000806103068361117c565b9050600061031762093a808361155d565b90508084106103325761032d8262093a8061155d565b610334565b815b949350505050565b6001600160a01b038281166000908152600560209081526040808320858452909152808220546002549151635058979360e01b81526004810186905292939092911690635058979390602401602060405180830381865afa1580156103a5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103c99190611575565b6000036103da5760009150506108c8565b6002546040516328a3532760e21b815260048101859052602481018390526000916001600160a01b03169063a28d4c9c90604401602060405180830381865afa15801561042b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061044f9190611575565b600254604051635058979360e01b8152600481018790529192506000916001916001600160a01b031690635058979390602401602060405180830381865afa15801561049f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104c39190611575565b6104cd919061158e565b905060006104ee604051806040016040528060008152602001600081525090565b6104f78561117c565b8152600080600185156106f457865b61051160018861158e565b81116106f257600254604051631277308160e21b8152600481018d9052602481018390526001600160a01b03909116906349dcc204906044016040805180830381865afa158015610566573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061058a91906115a5565b9094509250600061059a8561117c565b86519091508111156105b85760208601516105b5908861155d565b96505b8086526002546001600160a01b031663f7412baf816376f4be366105df62093a808661155d565b6040518263ffffffff1660e01b81526004016105fd91815260200190565b602060405180830381865afa15801561061a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061063e9190611575565b6040518263ffffffff1660e01b815260040161065c91815260200190565b6040805180830381865afa158015610678573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061069c91906115a5565b6001600160a01b038f1660009081526003602090815260408083208684529091529020549094508491506106d090866115c9565b6106da91906115fe565b602087015250806106ea81611612565b915050610506565b505b600254604051631277308160e21b8152600481018c9052602481018890526001600160a01b03909116906349dcc204906044016040805180830381865afa158015610743573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061076791906115a5565b909350915060006107778461117c565b9050600061078862093a808361155d565b905080421180156107985750808a105b156108bb57600254604051633b7a5f1b60e11b8152600481018390526001600160a01b039091169063f7412baf9082906376f4be3690602401602060405180830381865afa1580156107ee573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108129190611575565b6040518263ffffffff1660e01b815260040161083091815260200190565b6040805180830381865afa15801561084c573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061087091906115a5565b6001600160a01b038f1660009081526003602090815260408083208784529091529020549094508491506108a490866115c9565b6108ae91906115fe565b6108b8908861155d565b96505b5094985050505050505050505b92915050565b6001600160a01b0381166000908152600460205260408120546108c8904290611195565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166385f2aef26040518163ffffffff1660e01b81526004016020604051808303816000875af1158015610952573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610976919061162b565b6001600160a01b0316336001600160a01b0316146109c75760405162461bcd60e51b81526020600482015260096024820152686f6e6c79207465616d60b81b60448201526064015b60405180910390fd5b816001600160a01b0316600684815481106109e4576109e4611648565b6000918252602090912001546001600160a01b031614610a0357600080fd5b6001600160a01b03808316600090815260076020526040808220805460ff1990811690915592841682529020805490911660011790556006805482919085908110610a5057610a50611648565b9060005260206000200160006101000a8154816001600160a01b0302191690836001600160a01b03160217905550505050565b600080610a8f426102fa565b6001600160a01b039093166000908152600360209081526040808320958352949052929092205492915050565b600854600114610acb57600080fd5b6002600855336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610b0557600080fd5b6040516331a9108f60e11b8152600481018390526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690636352211e90602401602060405180830381865afa158015610b6d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b91919061162b565b905060005b8251811015610cb1576000610bc4848381518110610bb657610bb6611648565b60200260200101518661033c565b90504260056000868581518110610bdd57610bdd611648565b6020908102919091018101516001600160a01b0316825281810192909252604090810160009081208982529092529020558015610c3857610c38848381518110610c2957610c29611648565b602002602001015184836111ad565b838281518110610c4a57610c4a611648565b60200260200101516001600160a01b0316836001600160a01b03167f9aa05b3d70a9e3e2f004f039648839560576334fb45c81f91b6db03ad9e2efc983604051610c9691815260200190565b60405180910390a35080610ca981611612565b915050610b96565b505060016008555050565b600854600114610ccb57600080fd5b600260085580610cda57600080fd5b6001600160a01b03821660009081526007602052604090205460ff16610e2257604051633af32abf60e01b81526001600160a01b0383811660048301527f00000000000000000000000000000000000000000000000000000000000000001690633af32abf90602401602060405180830381865afa158015610d60573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d84919061165e565b610dd05760405162461bcd60e51b815260206004820181905260248201527f627269626520746f6b656e73206d7573742062652077686974656c697374656460448201526064016109be565b600654601011610e225760405162461bcd60e51b815260206004820152601760248201527f746f6f206d616e79207265776172647320746f6b656e7300000000000000000060448201526064016109be565b6000610e2d426102fa565b6001600160a01b0384166000908152600360209081526040808320848452909152902054909150610e608433308661129c565b610e6a838261155d565b6001600160a01b0385166000908152600360209081526040808320868452909152902055610e9b62093a808361155d565b6001600160a01b03851660009081526004602090815260408083209390935560079052205460ff16610f2d576001600160a01b0384166000818152600760205260408120805460ff191660019081179091556006805491820181559091527ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f0180546001600160a01b03191690911790555b60408051838152602081018590526001600160a01b0386169133917f52977ea98a2220a03ee9ba5cb003ada08d394ea10155483c95dc2dc77a7eb24b910160405180910390a3505060016008555050565b60068181548110610f8e57600080fd5b6000918252602090912001546001600160a01b0316905081565b600854600114610fb757600080fd5b600260085560405163430c208160e01b8152336004820152602481018390527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063430c208190604401602060405180830381865afa158015611027573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061104b919061165e565b61105457600080fd5b60005b815181101561117257600061108583838151811061107757611077611648565b60200260200101518561033c565b9050426005600085858151811061109e5761109e611648565b6020908102919091018101516001600160a01b03168252818101929092526040908101600090812088825290925290205580156110f9576110f98383815181106110ea576110ea611648565b602002602001015133836111ad565b82828151811061110b5761110b611648565b60200260200101516001600160a01b0316336001600160a01b03167f9aa05b3d70a9e3e2f004f039648839560576334fb45c81f91b6db03ad9e2efc98360405161115791815260200190565b60405180910390a3508061116a81611612565b915050611057565b5050600160085550565b600061118b62093a8083611680565b6108c8908361158e565b60008183106111a457816111a6565b825b9392505050565b6000836001600160a01b03163b116111c457600080fd5b604080516001600160a01b038481166024830152604480830185905283518084039091018152606490920183526020820180516001600160e01b031663a9059cbb60e01b17905291516000928392908716916112209190611694565b6000604051808303816000865af19150503d806000811461125d576040519150601f19603f3d011682016040523d82523d6000602084013e611262565b606091505b509150915081801561128c57508051158061128c57508080602001905181019061128c919061165e565b61129557600080fd5b5050505050565b6000846001600160a01b03163b116112b357600080fd5b604080516001600160a01b0385811660248301528481166044830152606480830185905283518084039091018152608490920183526020820180516001600160e01b03166323b872dd60e01b17905291516000928392908816916113179190611694565b6000604051808303816000865af19150503d8060008114611354576040519150601f19603f3d011682016040523d82523d6000602084013e611359565b606091505b5091509150818015611383575080511580611383575080806020019051810190611383919061165e565b61138c57600080fd5b505050505050565b6000602082840312156113a657600080fd5b5035919050565b6001600160a01b03811681146113c257600080fd5b50565b80356113d0816113ad565b919050565b600080604083850312156113e857600080fd5b82356113f3816113ad565b946020939093013593505050565b60006020828403121561141357600080fd5b81356111a6816113ad565b60008060006060848603121561143357600080fd5b833592506020840135611445816113ad565b91506040840135611455816113ad565b809150509250925092565b634e487b7160e01b600052604160045260246000fd5b6000806040838503121561148957600080fd5b8235915060208084013567ffffffffffffffff808211156114a957600080fd5b818601915086601f8301126114bd57600080fd5b8135818111156114cf576114cf611460565b8060051b604051601f19603f830116810181811085821117156114f4576114f4611460565b60405291825284820192508381018501918983111561151257600080fd5b938501935b8285101561153757611528856113c5565b84529385019392850192611517565b8096505050505050509250929050565b634e487b7160e01b600052601160045260246000fd5b6000821982111561157057611570611547565b500190565b60006020828403121561158757600080fd5b5051919050565b6000828210156115a0576115a0611547565b500390565b600080604083850312156115b857600080fd5b505080516020909101519092909150565b60008160001904831182151516156115e3576115e3611547565b500290565b634e487b7160e01b600052601260045260246000fd5b60008261160d5761160d6115e8565b500490565b60006001820161162457611624611547565b5060010190565b60006020828403121561163d57600080fd5b81516111a6816113ad565b634e487b7160e01b600052603260045260246000fd5b60006020828403121561167057600080fd5b815180151581146111a657600080fd5b60008261168f5761168f6115e8565b500690565b6000825160005b818110156116b5576020818601810151858301520161169b565b818111156116c4576000828501525b50919091019291505056fea2646970667358221220c9e5bbe2fafd43594ae504434755e0ffecca5247f78513515dcf3316b8bdfbdc64736f6c634300080d0033a2646970667358221220cdc870c083366d0871181bb5d744add4a7bda16ad74a60ac74131de93c4305d064736f6c634300080d0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100575760003560e01c80632fcd8f271461005c57806346c96aac146100a15780634bc2a657146100b45780636bd1a72c146100c9578063b1d0fc82146100dc575b600080fd5b61008561006a366004610287565b6003602052600090815260409020546001600160a01b031681565b6040516001600160a01b03909116815260200160405180910390f35b600254610085906001600160a01b031681565b6100c76100c2366004610287565b6100ef565b005b6100856100d7366004610287565b61017a565b600454610085906001600160a01b031681565b600154600160a01b900460ff16156101445760405162461bcd60e51b8152602060048201526013602482015272105b1c9958591e481a5b9a5d1a585b1a5e9959606a1b60448201526064015b60405180910390fd5b600280546001600160a01b039092166001600160a01b03199092169190911790556001805460ff60a01b1916600160a01b179055565b6001600160a01b03818116600090815260036020526040812054909116156101e45760405162461bcd60e51b815260206004820152601d60248201527f5772617070656420627269626520616c72656164792063726561746564000000604482015260640161013b565b6002546040516001600160a01b039091169083906102019061027a565b6001600160a01b03928316815291166020820152604001604051809103906000f080158015610234573d6000803e3d6000fd5b50600480546001600160a01b039283166001600160a01b031991821681178355948316600090815260036020526040902080549091169094179093559154909116919050565b611b22806102b883390190565b60006020828403121561029957600080fd5b81356001600160a01b03811681146102b057600080fd5b939250505056fe60c0604052600080546001600160a01b0319908116730a178469e3d08beaa0a289e416ab924f10807989179091556001805490911673ecf044c5b4b867cfda001101c617ecd347095b441781556008553480156200005c57600080fd5b5060405162001b2238038062001b228339810160408190526200007f9162000335565b6001600160a01b038216608081905260408051638dd598fb60e01b81529051638dd598fb916004808201926020929091908290030181865afa158015620000ca573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620000f091906200036d565b6001600160a01b0390811660a052600280546001600160a01b03191691831691909117905560005b600260009054906101000a90046001600160a01b03166001600160a01b031663e68863966040518163ffffffff1660e01b8152600401602060405180830381865afa1580156200016c573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062000192919062000392565b8110156200029957600254604051637980d7a160e11b8152600481018390526000916001600160a01b03169063f301af4290602401602060405180830381865afa158015620001e5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020b91906200036d565b90506001600160a01b0381161562000283576001600160a01b0381166000818152600760205260408120805460ff191660019081179091556006805491820181559091527ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f0180546001600160a01b03191690911790555b50806200029081620003ac565b91505062000118565b50600154600054604051632210724360e11b81526001600160a01b039182166004820152911690634420e486906024016020604051808303816000875af1158015620002e9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200030f919062000392565b505050620003d4565b80516001600160a01b03811681146200033057600080fd5b919050565b600080604083850312156200034957600080fd5b620003548362000318565b9150620003646020840162000318565b90509250929050565b6000602082840312156200038057600080fd5b6200038b8262000318565b9392505050565b600060208284031215620003a557600080fd5b5051919050565b600060018201620003cd57634e487b7160e01b600052601160045260246000fd5b5060010190565b60805160a0516117056200041d600039600081816101e6015281816108f401528181610b1e0152610fd801526000818161014e01528181610adb0152610d1901526117056000f3fe608060405234801561001057600080fd5b506004361061010b5760003560e01c80639418f939116100a2578063da09d19d11610071578063da09d19d14610281578063e6886396146102a1578063f25e55a5146102a9578063f301af42146102d4578063f5f8d365146102e757600080fd5b80639418f9391461023357806399bcc05214610248578063a7852afa1461025b578063b66503cf1461026e57600080fd5b8063638634ee116100de578063638634ee146101bb5780636c4f5398146101ce5780638dd598fb146101e157806392777b291461020857600080fd5b80630175e23b146101105780633e491d471461013657806346c96aac146101495780634d5ce03814610188575b600080fd5b61012361011e366004611394565b6102fa565b6040519081526020015b60405180910390f35b6101236101443660046113d5565b61033c565b6101707f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b03909116815260200161012d565b6101ab610196366004611401565b60076020526000908152604090205460ff1681565b604051901515815260200161012d565b6101236101c9366004611401565b6108ce565b600254610170906001600160a01b031681565b6101707f000000000000000000000000000000000000000000000000000000000000000081565b6101236102163660046113d5565b600360209081526000928352604080842090915290825290205481565b61024661024136600461141e565b6108f2565b005b610123610256366004611401565b610a83565b610246610269366004611476565b610abc565b61024661027c3660046113d5565b610cbc565b61012361028f366004611401565b60046020526000908152604090205481565b600654610123565b6101236102b73660046113d5565b600560209081526000928352604080842090915290825290205481565b6101706102e2366004611394565b610f7e565b6102466102f5366004611476565b610fa8565b6000806103068361117c565b9050600061031762093a808361155d565b90508084106103325761032d8262093a8061155d565b610334565b815b949350505050565b6001600160a01b038281166000908152600560209081526040808320858452909152808220546002549151635058979360e01b81526004810186905292939092911690635058979390602401602060405180830381865afa1580156103a5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103c99190611575565b6000036103da5760009150506108c8565b6002546040516328a3532760e21b815260048101859052602481018390526000916001600160a01b03169063a28d4c9c90604401602060405180830381865afa15801561042b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061044f9190611575565b600254604051635058979360e01b8152600481018790529192506000916001916001600160a01b031690635058979390602401602060405180830381865afa15801561049f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104c39190611575565b6104cd919061158e565b905060006104ee604051806040016040528060008152602001600081525090565b6104f78561117c565b8152600080600185156106f457865b61051160018861158e565b81116106f257600254604051631277308160e21b8152600481018d9052602481018390526001600160a01b03909116906349dcc204906044016040805180830381865afa158015610566573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061058a91906115a5565b9094509250600061059a8561117c565b86519091508111156105b85760208601516105b5908861155d565b96505b8086526002546001600160a01b031663f7412baf816376f4be366105df62093a808661155d565b6040518263ffffffff1660e01b81526004016105fd91815260200190565b602060405180830381865afa15801561061a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061063e9190611575565b6040518263ffffffff1660e01b815260040161065c91815260200190565b6040805180830381865afa158015610678573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061069c91906115a5565b6001600160a01b038f1660009081526003602090815260408083208684529091529020549094508491506106d090866115c9565b6106da91906115fe565b602087015250806106ea81611612565b915050610506565b505b600254604051631277308160e21b8152600481018c9052602481018890526001600160a01b03909116906349dcc204906044016040805180830381865afa158015610743573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061076791906115a5565b909350915060006107778461117c565b9050600061078862093a808361155d565b905080421180156107985750808a105b156108bb57600254604051633b7a5f1b60e11b8152600481018390526001600160a01b039091169063f7412baf9082906376f4be3690602401602060405180830381865afa1580156107ee573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108129190611575565b6040518263ffffffff1660e01b815260040161083091815260200190565b6040805180830381865afa15801561084c573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061087091906115a5565b6001600160a01b038f1660009081526003602090815260408083208784529091529020549094508491506108a490866115c9565b6108ae91906115fe565b6108b8908861155d565b96505b5094985050505050505050505b92915050565b6001600160a01b0381166000908152600460205260408120546108c8904290611195565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166385f2aef26040518163ffffffff1660e01b81526004016020604051808303816000875af1158015610952573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610976919061162b565b6001600160a01b0316336001600160a01b0316146109c75760405162461bcd60e51b81526020600482015260096024820152686f6e6c79207465616d60b81b60448201526064015b60405180910390fd5b816001600160a01b0316600684815481106109e4576109e4611648565b6000918252602090912001546001600160a01b031614610a0357600080fd5b6001600160a01b03808316600090815260076020526040808220805460ff1990811690915592841682529020805490911660011790556006805482919085908110610a5057610a50611648565b9060005260206000200160006101000a8154816001600160a01b0302191690836001600160a01b03160217905550505050565b600080610a8f426102fa565b6001600160a01b039093166000908152600360209081526040808320958352949052929092205492915050565b600854600114610acb57600080fd5b6002600855336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610b0557600080fd5b6040516331a9108f60e11b8152600481018390526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690636352211e90602401602060405180830381865afa158015610b6d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b91919061162b565b905060005b8251811015610cb1576000610bc4848381518110610bb657610bb6611648565b60200260200101518661033c565b90504260056000868581518110610bdd57610bdd611648565b6020908102919091018101516001600160a01b0316825281810192909252604090810160009081208982529092529020558015610c3857610c38848381518110610c2957610c29611648565b602002602001015184836111ad565b838281518110610c4a57610c4a611648565b60200260200101516001600160a01b0316836001600160a01b03167f9aa05b3d70a9e3e2f004f039648839560576334fb45c81f91b6db03ad9e2efc983604051610c9691815260200190565b60405180910390a35080610ca981611612565b915050610b96565b505060016008555050565b600854600114610ccb57600080fd5b600260085580610cda57600080fd5b6001600160a01b03821660009081526007602052604090205460ff16610e2257604051633af32abf60e01b81526001600160a01b0383811660048301527f00000000000000000000000000000000000000000000000000000000000000001690633af32abf90602401602060405180830381865afa158015610d60573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d84919061165e565b610dd05760405162461bcd60e51b815260206004820181905260248201527f627269626520746f6b656e73206d7573742062652077686974656c697374656460448201526064016109be565b600654601011610e225760405162461bcd60e51b815260206004820152601760248201527f746f6f206d616e79207265776172647320746f6b656e7300000000000000000060448201526064016109be565b6000610e2d426102fa565b6001600160a01b0384166000908152600360209081526040808320848452909152902054909150610e608433308661129c565b610e6a838261155d565b6001600160a01b0385166000908152600360209081526040808320868452909152902055610e9b62093a808361155d565b6001600160a01b03851660009081526004602090815260408083209390935560079052205460ff16610f2d576001600160a01b0384166000818152600760205260408120805460ff191660019081179091556006805491820181559091527ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f0180546001600160a01b03191690911790555b60408051838152602081018590526001600160a01b0386169133917f52977ea98a2220a03ee9ba5cb003ada08d394ea10155483c95dc2dc77a7eb24b910160405180910390a3505060016008555050565b60068181548110610f8e57600080fd5b6000918252602090912001546001600160a01b0316905081565b600854600114610fb757600080fd5b600260085560405163430c208160e01b8152336004820152602481018390527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063430c208190604401602060405180830381865afa158015611027573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061104b919061165e565b61105457600080fd5b60005b815181101561117257600061108583838151811061107757611077611648565b60200260200101518561033c565b9050426005600085858151811061109e5761109e611648565b6020908102919091018101516001600160a01b03168252818101929092526040908101600090812088825290925290205580156110f9576110f98383815181106110ea576110ea611648565b602002602001015133836111ad565b82828151811061110b5761110b611648565b60200260200101516001600160a01b0316336001600160a01b03167f9aa05b3d70a9e3e2f004f039648839560576334fb45c81f91b6db03ad9e2efc98360405161115791815260200190565b60405180910390a3508061116a81611612565b915050611057565b5050600160085550565b600061118b62093a8083611680565b6108c8908361158e565b60008183106111a457816111a6565b825b9392505050565b6000836001600160a01b03163b116111c457600080fd5b604080516001600160a01b038481166024830152604480830185905283518084039091018152606490920183526020820180516001600160e01b031663a9059cbb60e01b17905291516000928392908716916112209190611694565b6000604051808303816000865af19150503d806000811461125d576040519150601f19603f3d011682016040523d82523d6000602084013e611262565b606091505b509150915081801561128c57508051158061128c57508080602001905181019061128c919061165e565b61129557600080fd5b5050505050565b6000846001600160a01b03163b116112b357600080fd5b604080516001600160a01b0385811660248301528481166044830152606480830185905283518084039091018152608490920183526020820180516001600160e01b03166323b872dd60e01b17905291516000928392908816916113179190611694565b6000604051808303816000865af19150503d8060008114611354576040519150601f19603f3d011682016040523d82523d6000602084013e611359565b606091505b5091509150818015611383575080511580611383575080806020019051810190611383919061165e565b61138c57600080fd5b505050505050565b6000602082840312156113a657600080fd5b5035919050565b6001600160a01b03811681146113c257600080fd5b50565b80356113d0816113ad565b919050565b600080604083850312156113e857600080fd5b82356113f3816113ad565b946020939093013593505050565b60006020828403121561141357600080fd5b81356111a6816113ad565b60008060006060848603121561143357600080fd5b833592506020840135611445816113ad565b91506040840135611455816113ad565b809150509250925092565b634e487b7160e01b600052604160045260246000fd5b6000806040838503121561148957600080fd5b8235915060208084013567ffffffffffffffff808211156114a957600080fd5b818601915086601f8301126114bd57600080fd5b8135818111156114cf576114cf611460565b8060051b604051601f19603f830116810181811085821117156114f4576114f4611460565b60405291825284820192508381018501918983111561151257600080fd5b938501935b8285101561153757611528856113c5565b84529385019392850192611517565b8096505050505050509250929050565b634e487b7160e01b600052601160045260246000fd5b6000821982111561157057611570611547565b500190565b60006020828403121561158757600080fd5b5051919050565b6000828210156115a0576115a0611547565b500390565b600080604083850312156115b857600080fd5b505080516020909101519092909150565b60008160001904831182151516156115e3576115e3611547565b500290565b634e487b7160e01b600052601260045260246000fd5b60008261160d5761160d6115e8565b500490565b60006001820161162457611624611547565b5060010190565b60006020828403121561163d57600080fd5b81516111a6816113ad565b634e487b7160e01b600052603260045260246000fd5b60006020828403121561167057600080fd5b815180151581146111a657600080fd5b60008261168f5761168f6115e8565b500690565b6000825160005b818110156116b5576020818601810151858301520161169b565b818111156116c4576000828501525b50919091019291505056fea2646970667358221220c9e5bbe2fafd43594ae504434755e0ffecca5247f78513515dcf3316b8bdfbdc64736f6c634300080d0033a2646970667358221220cdc870c083366d0871181bb5d744add4a7bda16ad74a60ac74131de93c4305d064736f6c634300080d0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 22500,
        "contract": "contracts/factories/WrappedExternalBribeFactory.sol:WrappedExternalBribeFactory",
        "label": "multisig",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 22503,
        "contract": "contracts/factories/WrappedExternalBribeFactory.sol:WrappedExternalBribeFactory",
        "label": "turnstile",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 22505,
        "contract": "contracts/factories/WrappedExternalBribeFactory.sol:WrappedExternalBribeFactory",
        "label": "_initialized",
        "offset": 20,
        "slot": "1",
        "type": "t_bool"
      },
      {
        "astId": 22507,
        "contract": "contracts/factories/WrappedExternalBribeFactory.sol:WrappedExternalBribeFactory",
        "label": "voter",
        "offset": 0,
        "slot": "2",
        "type": "t_address"
      },
      {
        "astId": 22511,
        "contract": "contracts/factories/WrappedExternalBribeFactory.sol:WrappedExternalBribeFactory",
        "label": "oldBribeToNew",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_address,t_address)"
      },
      {
        "astId": 22513,
        "contract": "contracts/factories/WrappedExternalBribeFactory.sol:WrappedExternalBribeFactory",
        "label": "last_bribe",
        "offset": 0,
        "slot": "4",
        "type": "t_address"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_address)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      }
    }
  }
}