{
  "address": "0x76C9347739842E72509106e6aef616552bD0C9a7",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_voter",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "existing_bribe",
          "type": "address"
        }
      ],
      "name": "createBribe",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "last_bribe",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "oldBribeToNew",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "voter",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x1108f76fd230452fdc0732a9528c0f8257954178702f04a5dc763d34aee5cf16",
  "receipt": {
    "to": null,
    "from": "0x53f3B51FD7F327E1Ec4E6eAa3A049149cB2acaD2",
    "contractAddress": "0x76C9347739842E72509106e6aef616552bD0C9a7",
    "transactionIndex": 3,
    "gasUsed": "11333646",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x1c406f984b385a93f37729f64bc8a2b4ae40913808c4cee065716f60de1acab1",
    "transactionHash": "0x1108f76fd230452fdc0732a9528c0f8257954178702f04a5dc763d34aee5cf16",
    "logs": [],
    "blockNumber": 58032225,
    "cumulativeGasUsed": "13108501",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x2862Bf1ADC96d485B6E85C062b170903DE9A2Bd5"
  ],
  "numDeployments": 1,
  "solcInputHash": "816572db58a4a8203fcf6f77728173df",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"existing_bribe\",\"type\":\"address\"}],\"name\":\"createBribe\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"last_bribe\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"oldBribeToNew\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/factories/WrappedExternalBribeFactory.sol\":\"WrappedExternalBribeFactory\"},\"evmVersion\":\"london\",\"libraries\":{\":__CACHE_BREAKER__\":\"0x0000000000000031363735353339323034313033\"},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/ExternalBribe.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\\\";\\n\\nimport \\\"contracts/interfaces/IBribe.sol\\\";\\nimport \\\"contracts/interfaces/IERC20.sol\\\";\\nimport \\\"contracts/interfaces/IGauge.sol\\\";\\nimport \\\"contracts/interfaces/IVoter.sol\\\";\\nimport \\\"contracts/interfaces/IVotingEscrow.sol\\\";\\n\\n// Bribes pay out rewards for a given pool based on the votes that were received from the user (goes hand in hand with Voter.vote())\\ncontract ExternalBribe is IBribe {\\n    address public immutable voter; // only voter can modify balances (since it only happens on vote())\\n    address public immutable _ve; // \\u5929\\u4f7f\\u306e\\u305f\\u307e\\u3054\\n\\n    uint256 internal constant DURATION = 7 days; // rewards are released over the voting period\\n    uint256 internal constant MAX_REWARD_TOKENS = 16;\\n\\n    uint256 internal constant PRECISION = 10**18;\\n\\n    uint256 public totalSupply;\\n    mapping(uint256 => uint256) public balanceOf;\\n    mapping(address => mapping(uint256 => uint256)) public tokenRewardsPerEpoch;\\n    mapping(address => uint256) public periodFinish;\\n    mapping(address => mapping(uint256 => uint256)) public lastEarn;\\n\\n    address[] public rewards;\\n    mapping(address => bool) public isReward;\\n\\n    /// @notice A checkpoint for marking balance\\n    struct Checkpoint {\\n        uint256 timestamp;\\n        uint256 balanceOf;\\n    }\\n\\n    /// @notice A checkpoint for marking supply\\n    struct SupplyCheckpoint {\\n        uint256 timestamp;\\n        uint256 supply;\\n    }\\n\\n    /// @notice A record of balance checkpoints for each account, by index\\n    mapping(uint256 => mapping(uint256 => Checkpoint)) public checkpoints;\\n    /// @notice The number of checkpoints for each account\\n    mapping(uint256 => uint256) public numCheckpoints;\\n    /// @notice A record of balance checkpoints for each token, by index\\n    mapping(uint256 => SupplyCheckpoint) public supplyCheckpoints;\\n    /// @notice The number of checkpoints\\n    uint256 public supplyNumCheckpoints;\\n\\n    event Deposit(address indexed from, uint256 tokenId, uint256 amount);\\n    event Withdraw(address indexed from, uint256 tokenId, uint256 amount);\\n    event NotifyReward(\\n        address indexed from,\\n        address indexed reward,\\n        uint256 epoch,\\n        uint256 amount\\n    );\\n    event ClaimRewards(\\n        address indexed from,\\n        address indexed reward,\\n        uint256 amount\\n    );\\n\\n    constructor(address _voter, address[] memory _allowedRewardTokens) {\\n        voter = _voter;\\n        _ve = IVoter(_voter)._ve();\\n\\n        for (uint256 i; i < _allowedRewardTokens.length; i++) {\\n            if (_allowedRewardTokens[i] != address(0)) {\\n                isReward[_allowedRewardTokens[i]] = true;\\n                rewards.push(_allowedRewardTokens[i]);\\n            }\\n        }\\n    }\\n\\n    // simple re-entrancy check\\n    uint256 internal _unlocked = 1;\\n    modifier lock() {\\n        require(_unlocked == 1);\\n        _unlocked = 2;\\n        _;\\n        _unlocked = 1;\\n    }\\n\\n    function _bribeStart(uint256 timestamp) internal pure returns (uint256) {\\n        return timestamp - (timestamp % (7 days));\\n    }\\n\\n    function getEpochStart(uint256 timestamp) public pure returns (uint256) {\\n        uint256 bribeStart = _bribeStart(timestamp);\\n        uint256 bribeEnd = bribeStart + DURATION;\\n        return timestamp < bribeEnd ? bribeStart : bribeStart + 7 days;\\n    }\\n\\n    /**\\n     * @notice Determine the prior balance for an account as of a block number\\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\\n     * @param tokenId The token of the NFT to check\\n     * @param timestamp The timestamp to get the balance at\\n     * @return The balance the account had as of the given block\\n     */\\n    function getPriorBalanceIndex(uint256 tokenId, uint256 timestamp)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 nCheckpoints = numCheckpoints[tokenId];\\n        if (nCheckpoints == 0) {\\n            return 0;\\n        }\\n        // First check most recent balance\\n        if (checkpoints[tokenId][nCheckpoints - 1].timestamp <= timestamp) {\\n            return (nCheckpoints - 1);\\n        }\\n        // Next check implicit zero balance\\n        if (checkpoints[tokenId][0].timestamp > timestamp) {\\n            return 0;\\n        }\\n\\n        uint256 lower = 0;\\n        uint256 upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            Checkpoint memory cp = checkpoints[tokenId][center];\\n            if (cp.timestamp == timestamp) {\\n                return center;\\n            } else if (cp.timestamp < timestamp) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return lower;\\n    }\\n\\n    function getPriorSupplyIndex(uint256 timestamp)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 nCheckpoints = supplyNumCheckpoints;\\n        if (nCheckpoints == 0) {\\n            return 0;\\n        }\\n\\n        // First check most recent balance\\n        if (supplyCheckpoints[nCheckpoints - 1].timestamp <= timestamp) {\\n            return (nCheckpoints - 1);\\n        }\\n\\n        // Next check implicit zero balance\\n        if (supplyCheckpoints[0].timestamp > timestamp) {\\n            return 0;\\n        }\\n\\n        uint256 lower = 0;\\n        uint256 upper = nCheckpoints - 1;\\n        while (upper > lower) {\\n            uint256 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            SupplyCheckpoint memory cp = supplyCheckpoints[center];\\n            if (cp.timestamp == timestamp) {\\n                return center;\\n            } else if (cp.timestamp < timestamp) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return lower;\\n    }\\n\\n    function _writeCheckpoint(uint256 tokenId, uint256 balance) internal {\\n        uint256 _timestamp = block.timestamp;\\n        uint256 _nCheckPoints = numCheckpoints[tokenId];\\n        if (\\n            _nCheckPoints > 0 &&\\n            checkpoints[tokenId][_nCheckPoints - 1].timestamp == _timestamp\\n        ) {\\n            checkpoints[tokenId][_nCheckPoints - 1].balanceOf = balance;\\n        } else {\\n            checkpoints[tokenId][_nCheckPoints] = Checkpoint(\\n                _timestamp,\\n                balance\\n            );\\n            numCheckpoints[tokenId] = _nCheckPoints + 1;\\n        }\\n    }\\n\\n    function _writeSupplyCheckpoint() internal {\\n        uint256 _nCheckPoints = supplyNumCheckpoints;\\n        uint256 _timestamp = block.timestamp;\\n\\n        if (\\n            _nCheckPoints > 0 &&\\n            supplyCheckpoints[_nCheckPoints - 1].timestamp == _timestamp\\n        ) {\\n            supplyCheckpoints[_nCheckPoints - 1].supply = totalSupply;\\n        } else {\\n            supplyCheckpoints[_nCheckPoints] = SupplyCheckpoint(\\n                _timestamp,\\n                totalSupply\\n            );\\n            supplyNumCheckpoints = _nCheckPoints + 1;\\n        }\\n    }\\n\\n    function rewardsListLength() external view returns (uint256) {\\n        return rewards.length;\\n    }\\n\\n    // returns the last time the reward was modified or periodFinish if the reward has ended\\n    function lastTimeRewardApplicable(address token)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return Math.min(block.timestamp, periodFinish[token]);\\n    }\\n\\n    // allows a user to claim rewards for a given token\\n    function getReward(uint256 tokenId, address[] memory tokens) external lock {\\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, tokenId));\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            uint256 _reward = earned(tokens[i], tokenId);\\n            lastEarn[tokens[i]][tokenId] = block.timestamp;\\n            if (_reward > 0) _safeTransfer(tokens[i], msg.sender, _reward);\\n\\n            emit ClaimRewards(msg.sender, tokens[i], _reward);\\n        }\\n    }\\n\\n    // used by Voter to allow batched reward claims\\n    function getRewardForOwner(uint256 tokenId, address[] memory tokens)\\n        external\\n        lock\\n    {\\n        require(msg.sender == voter);\\n        address _owner = IVotingEscrow(_ve).ownerOf(tokenId);\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            uint256 _reward = earned(tokens[i], tokenId);\\n            lastEarn[tokens[i]][tokenId] = block.timestamp;\\n            if (_reward > 0) _safeTransfer(tokens[i], _owner, _reward);\\n\\n            emit ClaimRewards(_owner, tokens[i], _reward);\\n        }\\n    }\\n\\n    function earned(address token, uint256 tokenId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 _startTimestamp = lastEarn[token][tokenId];\\n        if (numCheckpoints[tokenId] == 0) {\\n            return 0;\\n        }\\n\\n        uint256 _startIndex = getPriorBalanceIndex(tokenId, _startTimestamp);\\n        uint256 _endIndex = numCheckpoints[tokenId] - 1;\\n\\n        uint256 reward = 0;\\n        // you only earn once per epoch (after it's over)\\n        Checkpoint memory prevRewards; // reuse struct to avoid stack too deep\\n        prevRewards.timestamp = _bribeStart(_startTimestamp);\\n        uint256 _prevSupply = 1;\\n\\n        if (_endIndex > 0) {\\n            for (uint256 i = _startIndex; i <= _endIndex - 1; i++) {\\n                Checkpoint memory cp0 = checkpoints[tokenId][i];\\n                uint256 _nextEpochStart = _bribeStart(cp0.timestamp);\\n                // check that you've earned it\\n                // this won't happen until a week has passed\\n                if (_nextEpochStart > prevRewards.timestamp) {\\n                    reward += prevRewards.balanceOf;\\n                }\\n\\n                prevRewards.timestamp = _nextEpochStart;\\n                _prevSupply = supplyCheckpoints[\\n                    getPriorSupplyIndex(_nextEpochStart + DURATION)\\n                ].supply;\\n                prevRewards.balanceOf =\\n                    (cp0.balanceOf *\\n                        tokenRewardsPerEpoch[token][_nextEpochStart]) /\\n                    _prevSupply;\\n            }\\n        }\\n\\n        Checkpoint memory cp = checkpoints[tokenId][_endIndex];\\n        uint256 _lastEpochStart = _bribeStart(cp.timestamp);\\n        uint256 _lastEpochEnd = _lastEpochStart + DURATION;\\n\\n        if (block.timestamp > _lastEpochEnd) {\\n            reward +=\\n                (cp.balanceOf * tokenRewardsPerEpoch[token][_lastEpochStart]) /\\n                supplyCheckpoints[getPriorSupplyIndex(_lastEpochEnd)].supply;\\n        }\\n\\n        return reward;\\n    }\\n\\n    // This is an external function, but internal notation is used since it can only be called \\\"internally\\\" from Gauges\\n    function _deposit(uint256 amount, uint256 tokenId) external {\\n        require(msg.sender == voter);\\n\\n        totalSupply += amount;\\n        balanceOf[tokenId] += amount;\\n\\n        _writeCheckpoint(tokenId, balanceOf[tokenId]);\\n        _writeSupplyCheckpoint();\\n\\n        emit Deposit(msg.sender, tokenId, amount);\\n    }\\n\\n    function _withdraw(uint256 amount, uint256 tokenId) external {\\n        require(msg.sender == voter);\\n\\n        totalSupply -= amount;\\n        balanceOf[tokenId] -= amount;\\n\\n        _writeCheckpoint(tokenId, balanceOf[tokenId]);\\n        _writeSupplyCheckpoint();\\n\\n        emit Withdraw(msg.sender, tokenId, amount);\\n    }\\n\\n    function left(address token) external view returns (uint256) {\\n        uint256 adjustedTstamp = getEpochStart(block.timestamp);\\n        return tokenRewardsPerEpoch[token][adjustedTstamp];\\n    }\\n\\n    function notifyRewardAmount(address token, uint256 amount) external lock {\\n        require(amount > 0);\\n        if (!isReward[token]) {\\n            require(\\n                IVoter(voter).isWhitelisted(token),\\n                \\\"bribe tokens must be whitelisted\\\"\\n            );\\n            require(\\n                rewards.length < MAX_REWARD_TOKENS,\\n                \\\"too many rewards tokens\\\"\\n            );\\n        }\\n        // bribes kick in at the start of next bribe period\\n        uint256 adjustedTstamp = getEpochStart(block.timestamp);\\n        uint256 epochRewards = tokenRewardsPerEpoch[token][adjustedTstamp];\\n\\n        _safeTransferFrom(token, msg.sender, address(this), amount);\\n        tokenRewardsPerEpoch[token][adjustedTstamp] = epochRewards + amount;\\n\\n        periodFinish[token] = adjustedTstamp + DURATION;\\n\\n        if (!isReward[token]) {\\n            isReward[token] = true;\\n            rewards.push(token);\\n        }\\n\\n        emit NotifyReward(msg.sender, token, adjustedTstamp, amount);\\n    }\\n\\n    function swapOutRewardToken(\\n        uint256 i,\\n        address oldToken,\\n        address newToken\\n    ) external {\\n        require(msg.sender == IVotingEscrow(_ve).team(), \\\"only team\\\");\\n        require(rewards[i] == oldToken);\\n        isReward[oldToken] = false;\\n        isReward[newToken] = true;\\n        rewards[i] = newToken;\\n    }\\n\\n    function _safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        require(token.code.length > 0);\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(IERC20.transfer.selector, to, value)\\n        );\\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\\n    }\\n\\n    function _safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        require(token.code.length > 0);\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(\\n                IERC20.transferFrom.selector,\\n                from,\\n                to,\\n                value\\n            )\\n        );\\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\\n    }\\n}\\n\",\"keccak256\":\"0x0026916e62de3e8d8c183fb2baea5512ef16c50760bf8e0f98a69de1e763a03f\",\"license\":\"MIT\"},\"contracts/WrappedExternalBribe.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\\\";\\nimport \\\"contracts/ExternalBribe.sol\\\";\\nimport \\\"contracts/interfaces/IERC20.sol\\\";\\nimport \\\"contracts/interfaces/IGauge.sol\\\";\\nimport \\\"contracts/interfaces/IVoter.sol\\\";\\nimport \\\"contracts/interfaces/IVotingEscrow.sol\\\";\\n\\n// Bribes pay out rewards for a given pool based on the votes that were received from the user (goes hand in hand with Voter.vote())\\ncontract WrappedExternalBribe {\\n    address public immutable voter;\\n    address public immutable _ve;\\n    ExternalBribe public underlying_bribe;\\n\\n    uint256 internal constant DURATION = 7 days; // rewards are released over the voting period\\n    uint256 internal constant MAX_REWARD_TOKENS = 16;\\n\\n    uint256 internal constant PRECISION = 10**18;\\n\\n    mapping(address => mapping(uint256 => uint256)) public tokenRewardsPerEpoch;\\n    mapping(address => uint256) public periodFinish;\\n    mapping(address => mapping(uint256 => uint256)) public lastEarn;\\n\\n    address[] public rewards;\\n    mapping(address => bool) public isReward;\\n\\n    /// @notice A checkpoint for marking balance\\n    struct RewardCheckpoint {\\n        uint256 timestamp;\\n        uint256 balance;\\n    }\\n\\n    event NotifyReward(\\n        address indexed from,\\n        address indexed reward,\\n        uint256 epoch,\\n        uint256 amount\\n    );\\n    event ClaimRewards(\\n        address indexed from,\\n        address indexed reward,\\n        uint256 amount\\n    );\\n\\n    constructor(address _voter, address _old_bribe) {\\n        voter = _voter;\\n        _ve = IVoter(_voter)._ve();\\n        underlying_bribe = ExternalBribe(_old_bribe);\\n\\n        for (uint256 i; i < underlying_bribe.rewardsListLength(); i++) {\\n            address underlying_reward = underlying_bribe.rewards(i);\\n            if (underlying_reward != address(0)) {\\n                isReward[underlying_reward] = true;\\n                rewards.push(underlying_reward);\\n            }\\n        }\\n    }\\n\\n    // simple re-entrancy check\\n    uint256 internal _unlocked = 1;\\n    modifier lock() {\\n        require(_unlocked == 1);\\n        _unlocked = 2;\\n        _;\\n        _unlocked = 1;\\n    }\\n\\n    function _bribeStart(uint256 timestamp) internal pure returns (uint256) {\\n        return timestamp - (timestamp % (7 days));\\n    }\\n\\n    function getEpochStart(uint256 timestamp) public pure returns (uint256) {\\n        uint256 bribeStart = _bribeStart(timestamp);\\n        uint256 bribeEnd = bribeStart + DURATION;\\n        return timestamp < bribeEnd ? bribeStart : bribeStart + 7 days;\\n    }\\n\\n    function rewardsListLength() external view returns (uint256) {\\n        return rewards.length;\\n    }\\n\\n    // returns the last time the reward was modified or periodFinish if the reward has ended\\n    function lastTimeRewardApplicable(address token)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return Math.min(block.timestamp, periodFinish[token]);\\n    }\\n\\n    // allows a user to claim rewards for a given token\\n    function getReward(uint256 tokenId, address[] memory tokens) external lock {\\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, tokenId));\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            uint256 _reward = earned(tokens[i], tokenId);\\n            lastEarn[tokens[i]][tokenId] = block.timestamp;\\n            if (_reward > 0) _safeTransfer(tokens[i], msg.sender, _reward);\\n\\n            emit ClaimRewards(msg.sender, tokens[i], _reward);\\n        }\\n    }\\n\\n    // used by Voter to allow batched reward claims\\n    function getRewardForOwner(uint256 tokenId, address[] memory tokens)\\n        external\\n        lock\\n    {\\n        require(msg.sender == voter);\\n        address _owner = IVotingEscrow(_ve).ownerOf(tokenId);\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            uint256 _reward = earned(tokens[i], tokenId);\\n            lastEarn[tokens[i]][tokenId] = block.timestamp;\\n            if (_reward > 0) _safeTransfer(tokens[i], _owner, _reward);\\n\\n            emit ClaimRewards(_owner, tokens[i], _reward);\\n        }\\n    }\\n\\n    function earned(address token, uint256 tokenId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 _startTimestamp = lastEarn[token][tokenId];\\n        if (underlying_bribe.numCheckpoints(tokenId) == 0) {\\n            return 0;\\n        }\\n\\n        uint256 _startIndex = underlying_bribe.getPriorBalanceIndex(\\n            tokenId,\\n            _startTimestamp\\n        );\\n        uint256 _endIndex = underlying_bribe.numCheckpoints(tokenId) - 1;\\n\\n        uint256 reward = 0;\\n        // you only earn once per epoch (after it's over)\\n        RewardCheckpoint memory prevRewards;\\n        prevRewards.timestamp = _bribeStart(_startTimestamp);\\n        uint256 _prevTs = 0;\\n        uint256 _prevBal = 0;\\n        uint256 _prevSupply = 1;\\n\\n        if (_endIndex > 0) {\\n            for (uint256 i = _startIndex; i <= _endIndex - 1; i++) {\\n                (_prevTs, _prevBal) = underlying_bribe.checkpoints(tokenId, i);\\n                uint256 _nextEpochStart = _bribeStart(_prevTs);\\n                // check that you've earned it\\n                // this won't happen until a week has passed\\n                if (_nextEpochStart > prevRewards.timestamp) {\\n                    reward += prevRewards.balance;\\n                }\\n\\n                prevRewards.timestamp = _nextEpochStart;\\n                (, _prevSupply) = underlying_bribe.supplyCheckpoints(\\n                    underlying_bribe.getPriorSupplyIndex(\\n                        _nextEpochStart + DURATION\\n                    )\\n                );\\n                prevRewards.balance =\\n                    (_prevBal * tokenRewardsPerEpoch[token][_nextEpochStart]) /\\n                    _prevSupply;\\n            }\\n        }\\n\\n        (_prevTs, _prevBal) = underlying_bribe.checkpoints(tokenId, _endIndex);\\n        uint256 _lastEpochStart = _bribeStart(_prevTs);\\n        uint256 _lastEpochEnd = _lastEpochStart + DURATION;\\n\\n        if (\\n            block.timestamp > _lastEpochEnd && _startTimestamp < _lastEpochEnd\\n        ) {\\n            (, _prevSupply) = underlying_bribe.supplyCheckpoints(\\n                underlying_bribe.getPriorSupplyIndex(_lastEpochEnd)\\n            );\\n            reward +=\\n                (_prevBal * tokenRewardsPerEpoch[token][_lastEpochStart]) /\\n                _prevSupply;\\n        }\\n\\n        return reward;\\n    }\\n\\n    function left(address token) external view returns (uint256) {\\n        uint256 adjustedTstamp = getEpochStart(block.timestamp);\\n        return tokenRewardsPerEpoch[token][adjustedTstamp];\\n    }\\n\\n    function notifyRewardAmount(address token, uint256 amount) external lock {\\n        require(amount > 0);\\n        if (!isReward[token]) {\\n            require(\\n                IVoter(voter).isWhitelisted(token),\\n                \\\"bribe tokens must be whitelisted\\\"\\n            );\\n            require(\\n                rewards.length < MAX_REWARD_TOKENS,\\n                \\\"too many rewards tokens\\\"\\n            );\\n        }\\n        // bribes kick in at the start of next bribe period\\n        uint256 adjustedTstamp = getEpochStart(block.timestamp);\\n        uint256 epochRewards = tokenRewardsPerEpoch[token][adjustedTstamp];\\n\\n        _safeTransferFrom(token, msg.sender, address(this), amount);\\n        tokenRewardsPerEpoch[token][adjustedTstamp] = epochRewards + amount;\\n\\n        periodFinish[token] = adjustedTstamp + DURATION;\\n\\n        if (!isReward[token]) {\\n            isReward[token] = true;\\n            rewards.push(token);\\n        }\\n\\n        emit NotifyReward(msg.sender, token, adjustedTstamp, amount);\\n    }\\n\\n    function swapOutRewardToken(\\n        uint256 i,\\n        address oldToken,\\n        address newToken\\n    ) external {\\n        require(msg.sender == IVotingEscrow(_ve).team(), \\\"only team\\\");\\n        require(rewards[i] == oldToken);\\n        isReward[oldToken] = false;\\n        isReward[newToken] = true;\\n        rewards[i] = newToken;\\n    }\\n\\n    function _safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        require(token.code.length > 0);\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(IERC20.transfer.selector, to, value)\\n        );\\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\\n    }\\n\\n    function _safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        require(token.code.length > 0);\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(\\n                IERC20.transferFrom.selector,\\n                from,\\n                to,\\n                value\\n            )\\n        );\\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\\n    }\\n}\\n\",\"keccak256\":\"0xd1bad333f3070b57462289a924c60cc20161cc4c349b7d3d99561e0b371cc200\",\"license\":\"MIT\"},\"contracts/factories/WrappedExternalBribeFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport {WrappedExternalBribe} from 'contracts/WrappedExternalBribe.sol';\\n\\ncontract WrappedExternalBribeFactory {\\n    address public immutable voter;\\n    mapping(address => address) public oldBribeToNew;\\n    address public last_bribe;\\n\\n    constructor(address _voter) {\\n        voter = _voter;\\n    }\\n\\n    function createBribe(address existing_bribe) external returns (address) {\\n        require(\\n            oldBribeToNew[existing_bribe] == address(0),\\n            \\\"Wrapped bribe already created\\\"\\n        );\\n        last_bribe = address(new WrappedExternalBribe(voter, existing_bribe));\\n        oldBribeToNew[existing_bribe] = last_bribe;\\n        return last_bribe;\\n    }\\n}\\n\",\"keccak256\":\"0x4e88b50000e3cf490ae8602b55555bbc02f95fda5926b1a532debfe54ac06bb2\",\"license\":\"MIT\"},\"contracts/interfaces/IBribe.sol\":{\"content\":\"pragma solidity 0.8.13;\\n\\ninterface IBribe {\\n    function _deposit(uint amount, uint tokenId) external;\\n    function _withdraw(uint amount, uint tokenId) external;\\n    function getRewardForOwner(uint tokenId, address[] memory tokens) external;\\n    function notifyRewardAmount(address token, uint amount) external;\\n    function left(address token) external view returns (uint);\\n}\\n\",\"keccak256\":\"0x51fd1163872f5d63b19f0c0f08b9b9a395dcadd79cf96cab749b898af01c1b4e\"},\"contracts/interfaces/IERC20.sol\":{\"content\":\"pragma solidity 0.8.13;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function transfer(address recipient, uint amount) external returns (bool);\\n    function decimals() external view returns (uint8);\\n    function symbol() external view returns (string memory);\\n    function balanceOf(address) external view returns (uint);\\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint);\\n    function approve(address spender, uint value) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint value);\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\",\"keccak256\":\"0x892b167ec5245b43ccdfc68d20e8ca12d05725fb6c11ec5ddf6bf77ed0c93c32\"},\"contracts/interfaces/IGauge.sol\":{\"content\":\"pragma solidity 0.8.13;\\n\\ninterface IGauge {\\n    function notifyRewardAmount(address token, uint amount) external;\\n    function getReward(address account, address[] memory tokens) external;\\n    function claimFees() external returns (uint claimed0, uint claimed1);\\n    function left(address token) external view returns (uint);\\n    function isForPair() external view returns (bool);\\n}\\n\",\"keccak256\":\"0xae388a0eeb0318da9a00bd65bcc80dcbf81cd24915959c7852f9fa21f8893865\"},\"contracts/interfaces/IVoter.sol\":{\"content\":\"pragma solidity 0.8.13;\\n\\ninterface IVoter {\\n    function _ve() external view returns (address);\\n    function governor() external view returns (address);\\n    function emergencyCouncil() external view returns (address);\\n    function attachTokenToGauge(uint _tokenId, address account) external;\\n    function detachTokenFromGauge(uint _tokenId, address account) external;\\n    function emitDeposit(uint _tokenId, address account, uint amount) external;\\n    function emitWithdraw(uint _tokenId, address account, uint amount) external;\\n    function isWhitelisted(address token) external view returns (bool);\\n    function notifyRewardAmount(uint amount) external;\\n    function distribute(address _gauge) external;\\n}\\n\",\"keccak256\":\"0x033115b88f156c6db67ca468fc9da8e4197bbd48bc8cf5a1652b9ebd307b2d31\"},\"contracts/interfaces/IVotingEscrow.sol\":{\"content\":\"pragma solidity 0.8.13;\\n\\ninterface IVotingEscrow {\\n\\n    struct Point {\\n        int128 bias;\\n        int128 slope; // # -dweight / dt\\n        uint256 ts;\\n        uint256 blk; // block\\n    }\\n\\n    function token() external view returns (address);\\n    function team() external returns (address);\\n    function epoch() external view returns (uint);\\n    function point_history(uint loc) external view returns (Point memory);\\n    function user_point_history(uint tokenId, uint loc) external view returns (Point memory);\\n    function user_point_epoch(uint tokenId) external view returns (uint);\\n\\n    function ownerOf(uint) external view returns (address);\\n    function isApprovedOrOwner(address, uint) external view returns (bool);\\n    function transferFrom(address, address, uint) external;\\n\\n    function voting(uint tokenId) external;\\n    function abstain(uint tokenId) external;\\n    function attach(uint tokenId) external;\\n    function detach(uint tokenId) external;\\n\\n    function checkpoint() external;\\n    function deposit_for(uint tokenId, uint value) external;\\n    function create_lock_for(uint, uint, address) external returns (uint);\\n\\n    function balanceOfNFT(uint) external view returns (uint);\\n    function totalSupply() external view returns (uint);\\n}\\n\",\"keccak256\":\"0x9c51afef11e82c70d08871264602e385a4f7caf36383e1bc5a6c214f93a4c0d1\"},\"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3546b156d97633f7f8cad536d5454c81d1d604687c02b2eb105fdc33cb962b41\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b50604051611d5d380380611d5d83398101604081905261002f91610040565b6001600160a01b0316608052610070565b60006020828403121561005257600080fd5b81516001600160a01b038116811461006957600080fd5b9392505050565b608051611ccc61009160003960008181609b01526101530152611ccc6000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c80632fcd8f271461005157806346c96aac146100965780636bd1a72c146100bd578063b1d0fc82146100d0575b600080fd5b61007a61005f366004610205565b6000602081905290815260409020546001600160a01b031681565b6040516001600160a01b03909116815260200160405180910390f35b61007a7f000000000000000000000000000000000000000000000000000000000000000081565b61007a6100cb366004610205565b6100e3565b60015461007a906001600160a01b031681565b6001600160a01b03818116600090815260208190526040812054909116156101515760405162461bcd60e51b815260206004820152601d60248201527f5772617070656420627269626520616c72656164792063726561746564000000604482015260640160405180910390fd5b7f00000000000000000000000000000000000000000000000000000000000000008260405161017f906101f8565b6001600160a01b03928316815291166020820152604001604051809103906000f0801580156101b2573d6000803e3d6000fd5b50600180546001600160a01b039283166001600160a01b031991821681178355948316600090815260208190526040902080549091169094179093559154909116919050565b611a618061023683390190565b60006020828403121561021757600080fd5b81356001600160a01b038116811461022e57600080fd5b939250505056fe60c060405260016006553480156200001657600080fd5b5060405162001a6138038062001a61833981016040819052620000399162000275565b6001600160a01b038216608081905260408051638dd598fb60e01b81529051638dd598fb916004808201926020929091908290030181865afa15801562000084573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620000aa9190620002ad565b6001600160a01b0390811660a052600080546001600160a01b0319169183169190911781555b60008054906101000a90046001600160a01b03166001600160a01b031663e68863966040518163ffffffff1660e01b8152600401602060405180830381865afa15801562000122573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620001489190620002d2565b8110156200024f5760008054604051637980d7a160e11b8152600481018490526001600160a01b039091169063f301af4290602401602060405180830381865afa1580156200019b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620001c19190620002ad565b90506001600160a01b0381161562000239576001600160a01b0381166000818152600560205260408120805460ff191660019081179091556004805491820181559091527f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b0180546001600160a01b03191690911790555b50806200024681620002ec565b915050620000d0565b50505062000314565b80516001600160a01b03811681146200027057600080fd5b919050565b600080604083850312156200028957600080fd5b620002948362000258565b9150620002a46020840162000258565b90509250929050565b600060208284031215620002c057600080fd5b620002cb8262000258565b9392505050565b600060208284031215620002e557600080fd5b5051919050565b6000600182016200030d57634e487b7160e01b600052601160045260246000fd5b5060010190565b60805160a0516117046200035d600039600081816101e6015281816108f301528181610b1d0152610fd701526000818161014e01528181610ada0152610d1801526117046000f3fe608060405234801561001057600080fd5b506004361061010b5760003560e01c80639418f939116100a2578063da09d19d11610071578063da09d19d14610281578063e6886396146102a1578063f25e55a5146102a9578063f301af42146102d4578063f5f8d365146102e757600080fd5b80639418f9391461023357806399bcc05214610248578063a7852afa1461025b578063b66503cf1461026e57600080fd5b8063638634ee116100de578063638634ee146101bb5780636c4f5398146101ce5780638dd598fb146101e157806392777b291461020857600080fd5b80630175e23b146101105780633e491d471461013657806346c96aac146101495780634d5ce03814610188575b600080fd5b61012361011e366004611393565b6102fa565b6040519081526020015b60405180910390f35b6101236101443660046113d4565b61033c565b6101707f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b03909116815260200161012d565b6101ab610196366004611400565b60056020526000908152604090205460ff1681565b604051901515815260200161012d565b6101236101c9366004611400565b6108cd565b600054610170906001600160a01b031681565b6101707f000000000000000000000000000000000000000000000000000000000000000081565b6101236102163660046113d4565b600160209081526000928352604080842090915290825290205481565b61024661024136600461141d565b6108f1565b005b610123610256366004611400565b610a82565b610246610269366004611475565b610abb565b61024661027c3660046113d4565b610cbb565b61012361028f366004611400565b60026020526000908152604090205481565b600454610123565b6101236102b73660046113d4565b600360209081526000928352604080842090915290825290205481565b6101706102e2366004611393565b610f7d565b6102466102f5366004611475565b610fa7565b6000806103068361117b565b9050600061031762093a808361155c565b90508084106103325761032d8262093a8061155c565b610334565b815b949350505050565b6001600160a01b0382811660009081526003602090815260408083208584529091528082205482549151635058979360e01b81526004810186905292939092911690635058979390602401602060405180830381865afa1580156103a4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103c89190611574565b6000036103d95760009150506108c7565b600080546040516328a3532760e21b815260048101869052602481018490526001600160a01b039091169063a28d4c9c90604401602060405180830381865afa15801561042a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061044e9190611574565b60008054604051635058979360e01b81526004810188905292935090916001916001600160a01b031690635058979390602401602060405180830381865afa15801561049e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104c29190611574565b6104cc919061158d565b905060006104ed604051806040016040528060008152602001600081525090565b6104f68561117b565b8152600080600185156106f357865b61051060018861158d565b81116106f157600054604051631277308160e21b8152600481018d9052602481018390526001600160a01b03909116906349dcc204906044016040805180830381865afa158015610565573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061058991906115a4565b909450925060006105998561117b565b86519091508111156105b75760208601516105b4908861155c565b96505b8086526000546001600160a01b031663f7412baf816376f4be366105de62093a808661155c565b6040518263ffffffff1660e01b81526004016105fc91815260200190565b602060405180830381865afa158015610619573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061063d9190611574565b6040518263ffffffff1660e01b815260040161065b91815260200190565b6040805180830381865afa158015610677573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061069b91906115a4565b6001600160a01b038f1660009081526001602090815260408083208684529091529020549094508491506106cf90866115c8565b6106d991906115fd565b602087015250806106e981611611565b915050610505565b505b600054604051631277308160e21b8152600481018c9052602481018890526001600160a01b03909116906349dcc204906044016040805180830381865afa158015610742573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061076691906115a4565b909350915060006107768461117b565b9050600061078762093a808361155c565b905080421180156107975750808a105b156108ba57600054604051633b7a5f1b60e11b8152600481018390526001600160a01b039091169063f7412baf9082906376f4be3690602401602060405180830381865afa1580156107ed573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108119190611574565b6040518263ffffffff1660e01b815260040161082f91815260200190565b6040805180830381865afa15801561084b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061086f91906115a4565b6001600160a01b038f1660009081526001602090815260408083208784529091529020549094508491506108a390866115c8565b6108ad91906115fd565b6108b7908861155c565b96505b5094985050505050505050505b92915050565b6001600160a01b0381166000908152600260205260408120546108c7904290611194565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166385f2aef26040518163ffffffff1660e01b81526004016020604051808303816000875af1158015610951573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610975919061162a565b6001600160a01b0316336001600160a01b0316146109c65760405162461bcd60e51b81526020600482015260096024820152686f6e6c79207465616d60b81b60448201526064015b60405180910390fd5b816001600160a01b0316600484815481106109e3576109e3611647565b6000918252602090912001546001600160a01b031614610a0257600080fd5b6001600160a01b03808316600090815260056020526040808220805460ff1990811690915592841682529020805490911660011790556004805482919085908110610a4f57610a4f611647565b9060005260206000200160006101000a8154816001600160a01b0302191690836001600160a01b03160217905550505050565b600080610a8e426102fa565b6001600160a01b039093166000908152600160209081526040808320958352949052929092205492915050565b600654600114610aca57600080fd5b6002600655336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610b0457600080fd5b6040516331a9108f60e11b8152600481018390526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690636352211e90602401602060405180830381865afa158015610b6c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b90919061162a565b905060005b8251811015610cb0576000610bc3848381518110610bb557610bb5611647565b60200260200101518661033c565b90504260036000868581518110610bdc57610bdc611647565b6020908102919091018101516001600160a01b0316825281810192909252604090810160009081208982529092529020558015610c3757610c37848381518110610c2857610c28611647565b602002602001015184836111ac565b838281518110610c4957610c49611647565b60200260200101516001600160a01b0316836001600160a01b03167f9aa05b3d70a9e3e2f004f039648839560576334fb45c81f91b6db03ad9e2efc983604051610c9591815260200190565b60405180910390a35080610ca881611611565b915050610b95565b505060016006555050565b600654600114610cca57600080fd5b600260065580610cd957600080fd5b6001600160a01b03821660009081526005602052604090205460ff16610e2157604051633af32abf60e01b81526001600160a01b0383811660048301527f00000000000000000000000000000000000000000000000000000000000000001690633af32abf90602401602060405180830381865afa158015610d5f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d83919061165d565b610dcf5760405162461bcd60e51b815260206004820181905260248201527f627269626520746f6b656e73206d7573742062652077686974656c697374656460448201526064016109bd565b600454601011610e215760405162461bcd60e51b815260206004820152601760248201527f746f6f206d616e79207265776172647320746f6b656e7300000000000000000060448201526064016109bd565b6000610e2c426102fa565b6001600160a01b0384166000908152600160209081526040808320848452909152902054909150610e5f8433308661129b565b610e69838261155c565b6001600160a01b0385166000908152600160209081526040808320868452909152902055610e9a62093a808361155c565b6001600160a01b03851660009081526002602090815260408083209390935560059052205460ff16610f2c576001600160a01b0384166000818152600560205260408120805460ff191660019081179091556004805491820181559091527f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b0180546001600160a01b03191690911790555b60408051838152602081018590526001600160a01b0386169133917f52977ea98a2220a03ee9ba5cb003ada08d394ea10155483c95dc2dc77a7eb24b910160405180910390a3505060016006555050565b60048181548110610f8d57600080fd5b6000918252602090912001546001600160a01b0316905081565b600654600114610fb657600080fd5b600260065560405163430c208160e01b8152336004820152602481018390527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063430c208190604401602060405180830381865afa158015611026573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061104a919061165d565b61105357600080fd5b60005b815181101561117157600061108483838151811061107657611076611647565b60200260200101518561033c565b9050426003600085858151811061109d5761109d611647565b6020908102919091018101516001600160a01b03168252818101929092526040908101600090812088825290925290205580156110f8576110f88383815181106110e9576110e9611647565b602002602001015133836111ac565b82828151811061110a5761110a611647565b60200260200101516001600160a01b0316336001600160a01b03167f9aa05b3d70a9e3e2f004f039648839560576334fb45c81f91b6db03ad9e2efc98360405161115691815260200190565b60405180910390a3508061116981611611565b915050611056565b5050600160065550565b600061118a62093a808361167f565b6108c7908361158d565b60008183106111a357816111a5565b825b9392505050565b6000836001600160a01b03163b116111c357600080fd5b604080516001600160a01b038481166024830152604480830185905283518084039091018152606490920183526020820180516001600160e01b031663a9059cbb60e01b179052915160009283929087169161121f9190611693565b6000604051808303816000865af19150503d806000811461125c576040519150601f19603f3d011682016040523d82523d6000602084013e611261565b606091505b509150915081801561128b57508051158061128b57508080602001905181019061128b919061165d565b61129457600080fd5b5050505050565b6000846001600160a01b03163b116112b257600080fd5b604080516001600160a01b0385811660248301528481166044830152606480830185905283518084039091018152608490920183526020820180516001600160e01b03166323b872dd60e01b17905291516000928392908816916113169190611693565b6000604051808303816000865af19150503d8060008114611353576040519150601f19603f3d011682016040523d82523d6000602084013e611358565b606091505b5091509150818015611382575080511580611382575080806020019051810190611382919061165d565b61138b57600080fd5b505050505050565b6000602082840312156113a557600080fd5b5035919050565b6001600160a01b03811681146113c157600080fd5b50565b80356113cf816113ac565b919050565b600080604083850312156113e757600080fd5b82356113f2816113ac565b946020939093013593505050565b60006020828403121561141257600080fd5b81356111a5816113ac565b60008060006060848603121561143257600080fd5b833592506020840135611444816113ac565b91506040840135611454816113ac565b809150509250925092565b634e487b7160e01b600052604160045260246000fd5b6000806040838503121561148857600080fd5b8235915060208084013567ffffffffffffffff808211156114a857600080fd5b818601915086601f8301126114bc57600080fd5b8135818111156114ce576114ce61145f565b8060051b604051601f19603f830116810181811085821117156114f3576114f361145f565b60405291825284820192508381018501918983111561151157600080fd5b938501935b8285101561153657611527856113c4565b84529385019392850192611516565b8096505050505050509250929050565b634e487b7160e01b600052601160045260246000fd5b6000821982111561156f5761156f611546565b500190565b60006020828403121561158657600080fd5b5051919050565b60008282101561159f5761159f611546565b500390565b600080604083850312156115b757600080fd5b505080516020909101519092909150565b60008160001904831182151516156115e2576115e2611546565b500290565b634e487b7160e01b600052601260045260246000fd5b60008261160c5761160c6115e7565b500490565b60006001820161162357611623611546565b5060010190565b60006020828403121561163c57600080fd5b81516111a5816113ac565b634e487b7160e01b600052603260045260246000fd5b60006020828403121561166f57600080fd5b815180151581146111a557600080fd5b60008261168e5761168e6115e7565b500690565b6000825160005b818110156116b4576020818601810151858301520161169a565b818111156116c3576000828501525b50919091019291505056fea26469706673582212204c68f24fbe87b92598fd129edadb7398ee5c00fbd53ee158cc73b9c2995c90eb64736f6c634300080d0033a26469706673582212208e50c0572ca7dbe34ebb03c2d342129b354ed41e5b340393120a3678bfa0ff1464736f6c634300080d0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061004c5760003560e01c80632fcd8f271461005157806346c96aac146100965780636bd1a72c146100bd578063b1d0fc82146100d0575b600080fd5b61007a61005f366004610205565b6000602081905290815260409020546001600160a01b031681565b6040516001600160a01b03909116815260200160405180910390f35b61007a7f000000000000000000000000000000000000000000000000000000000000000081565b61007a6100cb366004610205565b6100e3565b60015461007a906001600160a01b031681565b6001600160a01b03818116600090815260208190526040812054909116156101515760405162461bcd60e51b815260206004820152601d60248201527f5772617070656420627269626520616c72656164792063726561746564000000604482015260640160405180910390fd5b7f00000000000000000000000000000000000000000000000000000000000000008260405161017f906101f8565b6001600160a01b03928316815291166020820152604001604051809103906000f0801580156101b2573d6000803e3d6000fd5b50600180546001600160a01b039283166001600160a01b031991821681178355948316600090815260208190526040902080549091169094179093559154909116919050565b611a618061023683390190565b60006020828403121561021757600080fd5b81356001600160a01b038116811461022e57600080fd5b939250505056fe60c060405260016006553480156200001657600080fd5b5060405162001a6138038062001a61833981016040819052620000399162000275565b6001600160a01b038216608081905260408051638dd598fb60e01b81529051638dd598fb916004808201926020929091908290030181865afa15801562000084573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620000aa9190620002ad565b6001600160a01b0390811660a052600080546001600160a01b0319169183169190911781555b60008054906101000a90046001600160a01b03166001600160a01b031663e68863966040518163ffffffff1660e01b8152600401602060405180830381865afa15801562000122573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620001489190620002d2565b8110156200024f5760008054604051637980d7a160e11b8152600481018490526001600160a01b039091169063f301af4290602401602060405180830381865afa1580156200019b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620001c19190620002ad565b90506001600160a01b0381161562000239576001600160a01b0381166000818152600560205260408120805460ff191660019081179091556004805491820181559091527f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b0180546001600160a01b03191690911790555b50806200024681620002ec565b915050620000d0565b50505062000314565b80516001600160a01b03811681146200027057600080fd5b919050565b600080604083850312156200028957600080fd5b620002948362000258565b9150620002a46020840162000258565b90509250929050565b600060208284031215620002c057600080fd5b620002cb8262000258565b9392505050565b600060208284031215620002e557600080fd5b5051919050565b6000600182016200030d57634e487b7160e01b600052601160045260246000fd5b5060010190565b60805160a0516117046200035d600039600081816101e6015281816108f301528181610b1d0152610fd701526000818161014e01528181610ada0152610d1801526117046000f3fe608060405234801561001057600080fd5b506004361061010b5760003560e01c80639418f939116100a2578063da09d19d11610071578063da09d19d14610281578063e6886396146102a1578063f25e55a5146102a9578063f301af42146102d4578063f5f8d365146102e757600080fd5b80639418f9391461023357806399bcc05214610248578063a7852afa1461025b578063b66503cf1461026e57600080fd5b8063638634ee116100de578063638634ee146101bb5780636c4f5398146101ce5780638dd598fb146101e157806392777b291461020857600080fd5b80630175e23b146101105780633e491d471461013657806346c96aac146101495780634d5ce03814610188575b600080fd5b61012361011e366004611393565b6102fa565b6040519081526020015b60405180910390f35b6101236101443660046113d4565b61033c565b6101707f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b03909116815260200161012d565b6101ab610196366004611400565b60056020526000908152604090205460ff1681565b604051901515815260200161012d565b6101236101c9366004611400565b6108cd565b600054610170906001600160a01b031681565b6101707f000000000000000000000000000000000000000000000000000000000000000081565b6101236102163660046113d4565b600160209081526000928352604080842090915290825290205481565b61024661024136600461141d565b6108f1565b005b610123610256366004611400565b610a82565b610246610269366004611475565b610abb565b61024661027c3660046113d4565b610cbb565b61012361028f366004611400565b60026020526000908152604090205481565b600454610123565b6101236102b73660046113d4565b600360209081526000928352604080842090915290825290205481565b6101706102e2366004611393565b610f7d565b6102466102f5366004611475565b610fa7565b6000806103068361117b565b9050600061031762093a808361155c565b90508084106103325761032d8262093a8061155c565b610334565b815b949350505050565b6001600160a01b0382811660009081526003602090815260408083208584529091528082205482549151635058979360e01b81526004810186905292939092911690635058979390602401602060405180830381865afa1580156103a4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103c89190611574565b6000036103d95760009150506108c7565b600080546040516328a3532760e21b815260048101869052602481018490526001600160a01b039091169063a28d4c9c90604401602060405180830381865afa15801561042a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061044e9190611574565b60008054604051635058979360e01b81526004810188905292935090916001916001600160a01b031690635058979390602401602060405180830381865afa15801561049e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104c29190611574565b6104cc919061158d565b905060006104ed604051806040016040528060008152602001600081525090565b6104f68561117b565b8152600080600185156106f357865b61051060018861158d565b81116106f157600054604051631277308160e21b8152600481018d9052602481018390526001600160a01b03909116906349dcc204906044016040805180830381865afa158015610565573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061058991906115a4565b909450925060006105998561117b565b86519091508111156105b75760208601516105b4908861155c565b96505b8086526000546001600160a01b031663f7412baf816376f4be366105de62093a808661155c565b6040518263ffffffff1660e01b81526004016105fc91815260200190565b602060405180830381865afa158015610619573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061063d9190611574565b6040518263ffffffff1660e01b815260040161065b91815260200190565b6040805180830381865afa158015610677573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061069b91906115a4565b6001600160a01b038f1660009081526001602090815260408083208684529091529020549094508491506106cf90866115c8565b6106d991906115fd565b602087015250806106e981611611565b915050610505565b505b600054604051631277308160e21b8152600481018c9052602481018890526001600160a01b03909116906349dcc204906044016040805180830381865afa158015610742573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061076691906115a4565b909350915060006107768461117b565b9050600061078762093a808361155c565b905080421180156107975750808a105b156108ba57600054604051633b7a5f1b60e11b8152600481018390526001600160a01b039091169063f7412baf9082906376f4be3690602401602060405180830381865afa1580156107ed573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108119190611574565b6040518263ffffffff1660e01b815260040161082f91815260200190565b6040805180830381865afa15801561084b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061086f91906115a4565b6001600160a01b038f1660009081526001602090815260408083208784529091529020549094508491506108a390866115c8565b6108ad91906115fd565b6108b7908861155c565b96505b5094985050505050505050505b92915050565b6001600160a01b0381166000908152600260205260408120546108c7904290611194565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166385f2aef26040518163ffffffff1660e01b81526004016020604051808303816000875af1158015610951573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610975919061162a565b6001600160a01b0316336001600160a01b0316146109c65760405162461bcd60e51b81526020600482015260096024820152686f6e6c79207465616d60b81b60448201526064015b60405180910390fd5b816001600160a01b0316600484815481106109e3576109e3611647565b6000918252602090912001546001600160a01b031614610a0257600080fd5b6001600160a01b03808316600090815260056020526040808220805460ff1990811690915592841682529020805490911660011790556004805482919085908110610a4f57610a4f611647565b9060005260206000200160006101000a8154816001600160a01b0302191690836001600160a01b03160217905550505050565b600080610a8e426102fa565b6001600160a01b039093166000908152600160209081526040808320958352949052929092205492915050565b600654600114610aca57600080fd5b6002600655336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610b0457600080fd5b6040516331a9108f60e11b8152600481018390526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690636352211e90602401602060405180830381865afa158015610b6c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b90919061162a565b905060005b8251811015610cb0576000610bc3848381518110610bb557610bb5611647565b60200260200101518661033c565b90504260036000868581518110610bdc57610bdc611647565b6020908102919091018101516001600160a01b0316825281810192909252604090810160009081208982529092529020558015610c3757610c37848381518110610c2857610c28611647565b602002602001015184836111ac565b838281518110610c4957610c49611647565b60200260200101516001600160a01b0316836001600160a01b03167f9aa05b3d70a9e3e2f004f039648839560576334fb45c81f91b6db03ad9e2efc983604051610c9591815260200190565b60405180910390a35080610ca881611611565b915050610b95565b505060016006555050565b600654600114610cca57600080fd5b600260065580610cd957600080fd5b6001600160a01b03821660009081526005602052604090205460ff16610e2157604051633af32abf60e01b81526001600160a01b0383811660048301527f00000000000000000000000000000000000000000000000000000000000000001690633af32abf90602401602060405180830381865afa158015610d5f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d83919061165d565b610dcf5760405162461bcd60e51b815260206004820181905260248201527f627269626520746f6b656e73206d7573742062652077686974656c697374656460448201526064016109bd565b600454601011610e215760405162461bcd60e51b815260206004820152601760248201527f746f6f206d616e79207265776172647320746f6b656e7300000000000000000060448201526064016109bd565b6000610e2c426102fa565b6001600160a01b0384166000908152600160209081526040808320848452909152902054909150610e5f8433308661129b565b610e69838261155c565b6001600160a01b0385166000908152600160209081526040808320868452909152902055610e9a62093a808361155c565b6001600160a01b03851660009081526002602090815260408083209390935560059052205460ff16610f2c576001600160a01b0384166000818152600560205260408120805460ff191660019081179091556004805491820181559091527f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b0180546001600160a01b03191690911790555b60408051838152602081018590526001600160a01b0386169133917f52977ea98a2220a03ee9ba5cb003ada08d394ea10155483c95dc2dc77a7eb24b910160405180910390a3505060016006555050565b60048181548110610f8d57600080fd5b6000918252602090912001546001600160a01b0316905081565b600654600114610fb657600080fd5b600260065560405163430c208160e01b8152336004820152602481018390527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063430c208190604401602060405180830381865afa158015611026573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061104a919061165d565b61105357600080fd5b60005b815181101561117157600061108483838151811061107657611076611647565b60200260200101518561033c565b9050426003600085858151811061109d5761109d611647565b6020908102919091018101516001600160a01b03168252818101929092526040908101600090812088825290925290205580156110f8576110f88383815181106110e9576110e9611647565b602002602001015133836111ac565b82828151811061110a5761110a611647565b60200260200101516001600160a01b0316336001600160a01b03167f9aa05b3d70a9e3e2f004f039648839560576334fb45c81f91b6db03ad9e2efc98360405161115691815260200190565b60405180910390a3508061116981611611565b915050611056565b5050600160065550565b600061118a62093a808361167f565b6108c7908361158d565b60008183106111a357816111a5565b825b9392505050565b6000836001600160a01b03163b116111c357600080fd5b604080516001600160a01b038481166024830152604480830185905283518084039091018152606490920183526020820180516001600160e01b031663a9059cbb60e01b179052915160009283929087169161121f9190611693565b6000604051808303816000865af19150503d806000811461125c576040519150601f19603f3d011682016040523d82523d6000602084013e611261565b606091505b509150915081801561128b57508051158061128b57508080602001905181019061128b919061165d565b61129457600080fd5b5050505050565b6000846001600160a01b03163b116112b257600080fd5b604080516001600160a01b0385811660248301528481166044830152606480830185905283518084039091018152608490920183526020820180516001600160e01b03166323b872dd60e01b17905291516000928392908816916113169190611693565b6000604051808303816000865af19150503d8060008114611353576040519150601f19603f3d011682016040523d82523d6000602084013e611358565b606091505b5091509150818015611382575080511580611382575080806020019051810190611382919061165d565b61138b57600080fd5b505050505050565b6000602082840312156113a557600080fd5b5035919050565b6001600160a01b03811681146113c157600080fd5b50565b80356113cf816113ac565b919050565b600080604083850312156113e757600080fd5b82356113f2816113ac565b946020939093013593505050565b60006020828403121561141257600080fd5b81356111a5816113ac565b60008060006060848603121561143257600080fd5b833592506020840135611444816113ac565b91506040840135611454816113ac565b809150509250925092565b634e487b7160e01b600052604160045260246000fd5b6000806040838503121561148857600080fd5b8235915060208084013567ffffffffffffffff808211156114a857600080fd5b818601915086601f8301126114bc57600080fd5b8135818111156114ce576114ce61145f565b8060051b604051601f19603f830116810181811085821117156114f3576114f361145f565b60405291825284820192508381018501918983111561151157600080fd5b938501935b8285101561153657611527856113c4565b84529385019392850192611516565b8096505050505050509250929050565b634e487b7160e01b600052601160045260246000fd5b6000821982111561156f5761156f611546565b500190565b60006020828403121561158657600080fd5b5051919050565b60008282101561159f5761159f611546565b500390565b600080604083850312156115b757600080fd5b505080516020909101519092909150565b60008160001904831182151516156115e2576115e2611546565b500290565b634e487b7160e01b600052601260045260246000fd5b60008261160c5761160c6115e7565b500490565b60006001820161162357611623611546565b5060010190565b60006020828403121561163c57600080fd5b81516111a5816113ac565b634e487b7160e01b600052603260045260246000fd5b60006020828403121561166f57600080fd5b815180151581146111a557600080fd5b60008261168e5761168e6115e7565b500690565b6000825160005b818110156116b4576020818601810151858301520161169a565b818111156116c3576000828501525b50919091019291505056fea26469706673582212204c68f24fbe87b92598fd129edadb7398ee5c00fbd53ee158cc73b9c2995c90eb64736f6c634300080d0033a26469706673582212208e50c0572ca7dbe34ebb03c2d342129b354ed41e5b340393120a3678bfa0ff1464736f6c634300080d0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 21862,
        "contract": "contracts/factories/WrappedExternalBribeFactory.sol:WrappedExternalBribeFactory",
        "label": "oldBribeToNew",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_address)"
      },
      {
        "astId": 21864,
        "contract": "contracts/factories/WrappedExternalBribeFactory.sol:WrappedExternalBribeFactory",
        "label": "last_bribe",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_address)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      }
    }
  }
}